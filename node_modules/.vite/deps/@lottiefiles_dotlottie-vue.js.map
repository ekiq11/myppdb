{
  "version": 3,
  "sources": ["../../@lottiefiles/dotlottie-web/src/animation-frame-manager.ts", "../../@lottiefiles/dotlottie-web/src/constants.ts", "../../@lottiefiles/dotlottie-web/package.json", "../../@lottiefiles/dotlottie-web/src/core/dotlottie-player.js", "../../@lottiefiles/dotlottie-web/src/core/dotlottie-wasm-loader.ts", "../../@lottiefiles/dotlottie-web/src/event-manager.ts", "../../@lottiefiles/dotlottie-web/src/dotlottie.ts", "../../@lottiefiles/dotlottie-vue/dist/index.js"],
  "sourcesContent": ["/**\n * Copyright 2023 Design Barn Inc.\n */\n\n/* eslint-disable max-classes-per-file */\n\ninterface AnimationFrameStrategy {\n  cancelAnimationFrame(id: number): void;\n  requestAnimationFrame(callback: (time: number) => void): number;\n}\n\nclass WebAnimationFrameStrategy implements AnimationFrameStrategy {\n  public requestAnimationFrame(callback: (time: number) => void): number {\n    return requestAnimationFrame(callback);\n  }\n\n  public cancelAnimationFrame(id: number): void {\n    cancelAnimationFrame(id);\n  }\n}\n\nclass NodeAnimationFrameStrategy implements AnimationFrameStrategy {\n  private _lastHandleId: number = 0;\n\n  private _lastImmediate: NodeJS.Immediate | null = null;\n\n  public requestAnimationFrame(callback: (time: number) => void): number {\n    if (this._lastHandleId >= Number.MAX_SAFE_INTEGER) {\n      this._lastHandleId = 0;\n    }\n\n    this._lastHandleId += 1;\n\n    this._lastImmediate = setImmediate(() => {\n      callback(Date.now());\n    });\n\n    return this._lastHandleId;\n  }\n\n  public cancelAnimationFrame(_id: number): void {\n    if (this._lastImmediate) {\n      clearImmediate(this._lastImmediate);\n    }\n  }\n}\n\nexport class AnimationFrameManager {\n  private readonly _strategy: AnimationFrameStrategy;\n\n  public constructor() {\n    this._strategy =\n      typeof requestAnimationFrame === 'function' ? new WebAnimationFrameStrategy() : new NodeAnimationFrameStrategy();\n  }\n\n  public requestAnimationFrame(callback: (time: number) => void): number {\n    return this._strategy.requestAnimationFrame(callback);\n  }\n\n  public cancelAnimationFrame(id: number): void {\n    this._strategy.cancelAnimationFrame(id);\n  }\n}\n", "/**\n * Copyright 2023 Design Barn Inc.\n */\n\nexport const IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';\nexport const MS_TO_SEC_FACTOR = 1000;\nexport const DEFAULT_BG_COLOR = '#00000000';\n", "{\n  \"name\": \"@lottiefiles/dotlottie-web\",\n  \"version\": \"0.15.0\",\n  \"type\": \"module\",\n  \"description\": \"Lottie and DotLottie player for the web\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/LottieFiles/dotlottie-web.git\",\n    \"directory\": \"packages/web\"\n  },\n  \"homepage\": \"https://github.com/LottieFiles/dotlottie-web#readme\",\n  \"bugs\": \"https://github.com/LottieFiles/dotlottie-web/issues\",\n  \"author\": \"LottieFiles\",\n  \"contributors\": [\n    \"Abdelrahman Ashraf <a.theashraf@gmail.com>\"\n  ],\n  \"license\": \"MIT\",\n  \"engines\": {\n    \"node\": \">=18\"\n  },\n  \"main\": \"dist/index.cjs\",\n  \"module\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"keywords\": [\n    \"dotlottie\",\n    \"lottie\",\n    \"player\",\n    \"animation\",\n    \"web\",\n    \"canvas\",\n    \"javascript\",\n    \"thorvg\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch\",\n    \"lint\": \"eslint --fix .\",\n    \"stats:eslint\": \"cross-env TIMING=1 eslint .\",\n    \"stats:ts\": \"tsc -p tsconfig.build.json --extendedDiagnostics\",\n    \"test\": \"vitest run --browser.headless\",\n    \"test:coverage\": \"vitest run --browser.headless --coverage\",\n    \"test:watch\": \"vitest\",\n    \"type-check\": \"tsc --noEmit\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.10.5\",\n    \"@vitest/browser\": \"^1.2.2 \",\n    \"@vitest/coverage-istanbul\": \"^1.2.2\",\n    \"cross-env\": \"7.0.3\",\n    \"tsup\": \"8.0.1\",\n    \"typescript\": \"5.0.4\",\n    \"vitest\": \"^1.2.2\",\n    \"webdriverio\": \"^8.32.0\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\"\n  }\n}\n", "var createDotLottiePlayerModule = (() => {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n\n  return function (moduleArg = {}) {\n    var Module = moduleArg;\n\n    var readyPromiseResolve, readyPromiseReject;\n\n    Module['ready'] = new Promise((resolve, reject) => {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n\n    var moduleOverrides = Object.assign({}, Module);\n\n    var arguments_ = [];\n\n    var thisProgram = './this.program';\n\n    var quit_ = (status, toThrow) => {\n      throw toThrow;\n    };\n\n    var ENVIRONMENT_IS_WEB = true;\n\n    var ENVIRONMENT_IS_WORKER = false;\n\n    var scriptDirectory = '';\n\n    function locateFile(path) {\n      if (Module['locateFile']) {\n        return Module['locateFile'](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n\n    var read_, readAsync, readBinary;\n\n    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (typeof document != 'undefined' && document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n      if (scriptDirectory.indexOf('blob:') !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1);\n      } else {\n        scriptDirectory = '';\n      }\n      {\n        read_ = (url) => {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', url, false);\n          xhr.send(null);\n          return xhr.responseText;\n        };\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = (url) => {\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', url, false);\n            xhr.responseType = 'arraybuffer';\n            xhr.send(null);\n            return new Uint8Array(/** @type{!ArrayBuffer} */ (xhr.response));\n          };\n        }\n        readAsync = (url, onload, onerror) => {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', url, true);\n          xhr.responseType = 'arraybuffer';\n          xhr.onload = () => {\n            if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {\n              onload(xhr.response);\n              return;\n            }\n            onerror();\n          };\n          xhr.onerror = onerror;\n          xhr.send(null);\n        };\n      }\n    } else {\n    }\n\n    var out = Module['print'] || console.log.bind(console);\n\n    var err = Module['printErr'] || console.error.bind(console);\n\n    Object.assign(Module, moduleOverrides);\n\n    moduleOverrides = null;\n\n    if (Module['arguments']) arguments_ = Module['arguments'];\n\n    if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n\n    if (Module['quit']) quit_ = Module['quit'];\n\n    var wasmBinary;\n\n    if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\n\n    if (typeof WebAssembly != 'object') {\n      abort('no native wasm support detected');\n    }\n\n    var wasmMemory;\n\n    var ABORT = false;\n\n    var EXITSTATUS;\n\n    var /** @type {!Int8Array} */ HEAP8,\n      /** @type {!Uint8Array} */ HEAPU8,\n      /** @type {!Int16Array} */ HEAP16,\n      /** @type {!Uint16Array} */ HEAPU16,\n      /** @type {!Int32Array} */ HEAP32,\n      /** @type {!Uint32Array} */ HEAPU32,\n      /** @type {!Float32Array} */ HEAPF32,\n      /** @type {!Float64Array} */ HEAPF64;\n\n    function updateMemoryViews() {\n      var b = wasmMemory.buffer;\n      Module['HEAP8'] = HEAP8 = new Int8Array(b);\n      Module['HEAP16'] = HEAP16 = new Int16Array(b);\n      Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);\n      Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);\n      Module['HEAP32'] = HEAP32 = new Int32Array(b);\n      Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);\n      Module['HEAPF32'] = HEAPF32 = new Float32Array(b);\n      Module['HEAPF64'] = HEAPF64 = new Float64Array(b);\n    }\n\n    var __ATPRERUN__ = [];\n\n    var __ATINIT__ = [];\n\n    var __ATPOSTRUN__ = [];\n\n    var runtimeInitialized = false;\n\n    function preRun() {\n      if (Module['preRun']) {\n        if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n        while (Module['preRun'].length) {\n          addOnPreRun(Module['preRun'].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function initRuntime() {\n      runtimeInitialized = true;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function postRun() {\n      if (Module['postRun']) {\n        if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n        while (Module['postRun'].length) {\n          addOnPostRun(Module['postRun'].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n\n    var runDependencies = 0;\n\n    var runDependencyWatcher = null;\n\n    var dependenciesFulfilled = null;\n\n    function addRunDependency(id) {\n      runDependencies++;\n      Module['monitorRunDependencies']?.(runDependencies);\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n      Module['monitorRunDependencies']?.(runDependencies);\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n\n    /** @param {string|number=} what */ function abort(what) {\n      Module['onAbort']?.(what);\n      what = 'Aborted(' + what + ')';\n      err(what);\n      ABORT = true;\n      EXITSTATUS = 1;\n      what += '. Build with -sASSERTIONS for more info.';\n      /** @suppress {checkTypes} */ var e = new WebAssembly.RuntimeError(what);\n      readyPromiseReject(e);\n      throw e;\n    }\n\n    var dataURIPrefix = 'data:application/octet-stream;base64,';\n\n    /**\n     * Indicates whether filename is a base64 data URI.\n     * @noinline\n     */ var isDataURI = (filename) => filename.startsWith(dataURIPrefix);\n\n    var wasmBinaryFile;\n\n    wasmBinaryFile = 'DotLottiePlayer.wasm';\n\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n\n    function getBinarySync(file) {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      if (readBinary) {\n        return readBinary(file);\n      }\n      throw 'both async and sync fetching of the wasm failed';\n    }\n\n    function getBinaryPromise(binaryFile) {\n      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n        if (typeof fetch == 'function') {\n          return fetch(binaryFile, {\n            credentials: 'same-origin',\n          })\n            .then((response) => {\n              if (!response['ok']) {\n                throw \"failed to load wasm binary file at '\" + binaryFile + \"'\";\n              }\n              return response['arrayBuffer']();\n            })\n            .catch(() => getBinarySync(binaryFile));\n        }\n      }\n      return Promise.resolve().then(() => getBinarySync(binaryFile));\n    }\n\n    function instantiateArrayBuffer(binaryFile, imports, receiver) {\n      return getBinaryPromise(binaryFile)\n        .then((binary) => WebAssembly.instantiate(binary, imports))\n        .then((instance) => instance)\n        .then(receiver, (reason) => {\n          err(`failed to asynchronously prepare wasm: ${reason}`);\n          abort(reason);\n        });\n    }\n\n    function instantiateAsync(binary, binaryFile, imports, callback) {\n      if (\n        !binary &&\n        typeof WebAssembly.instantiateStreaming == 'function' &&\n        !isDataURI(binaryFile) &&\n        typeof fetch == 'function'\n      ) {\n        return fetch(binaryFile, {\n          credentials: 'same-origin',\n        }).then((response) => {\n          /** @suppress {checkTypes} */ var result = WebAssembly.instantiateStreaming(response, imports);\n          return result.then(callback, function (reason) {\n            err(`wasm streaming compile failed: ${reason}`);\n            err('falling back to ArrayBuffer instantiation');\n            return instantiateArrayBuffer(binaryFile, imports, callback);\n          });\n        });\n      }\n      return instantiateArrayBuffer(binaryFile, imports, callback);\n    }\n\n    function createWasm() {\n      var info = {\n        a: wasmImports,\n      };\n      /** @param {WebAssembly.Module=} module*/ function receiveInstance(instance, module) {\n        wasmExports = instance.exports;\n        wasmMemory = wasmExports['Z'];\n        updateMemoryViews();\n        wasmTable = wasmExports['aa'];\n        addOnInit(wasmExports['_']);\n        removeRunDependency('wasm-instantiate');\n        return wasmExports;\n      }\n      addRunDependency('wasm-instantiate');\n      function receiveInstantiationResult(result) {\n        receiveInstance(result['instance']);\n      }\n      if (Module['instantiateWasm']) {\n        try {\n          return Module['instantiateWasm'](info, receiveInstance);\n        } catch (e) {\n          err(`Module.instantiateWasm callback failed with error: ${e}`);\n          readyPromiseReject(e);\n        }\n      }\n      instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n      return {};\n    }\n\n    var callRuntimeCallbacks = (callbacks) => {\n      while (callbacks.length > 0) {\n        callbacks.shift()(Module);\n      }\n    };\n\n    var noExitRuntime = Module['noExitRuntime'] || true;\n\n    var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;\n\n    /**\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n     * array that contains uint8 values, returns a copy of that string as a\n     * Javascript String object.\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\n     * @param {number} idx\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */ var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = '';\n      while (idx < endPtr) {\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 128)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 224) == 192) {\n          str += String.fromCharCode(((u0 & 31) << 6) | u1);\n          continue;\n        }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 240) == 224) {\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n        } else {\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n        }\n        if (u0 < 65536) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 65536;\n          str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\n        }\n      }\n      return str;\n    };\n\n    /**\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\n     *\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead - An optional length that specifies the\n     *   maximum number of bytes to read. You can omit this parameter to scan the\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\n     * @return {string}\n     */ var UTF8ToString = (ptr, maxBytesToRead) => (ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '');\n\n    var ___assert_fail = (condition, filename, line, func) => {\n      abort(\n        `Assertion failed: ${UTF8ToString(condition)}, at: ` +\n          [\n            filename ? UTF8ToString(filename) : 'unknown filename',\n            line,\n            func ? UTF8ToString(func) : 'unknown function',\n          ],\n      );\n    };\n\n    /** @constructor */ function ExceptionInfo(excPtr) {\n      this.excPtr = excPtr;\n      this.ptr = excPtr - 24;\n      this.set_type = function (type) {\n        HEAPU32[(this.ptr + 4) >> 2] = type;\n      };\n      this.get_type = function () {\n        return HEAPU32[(this.ptr + 4) >> 2];\n      };\n      this.set_destructor = function (destructor) {\n        HEAPU32[(this.ptr + 8) >> 2] = destructor;\n      };\n      this.get_destructor = function () {\n        return HEAPU32[(this.ptr + 8) >> 2];\n      };\n      this.set_caught = function (caught) {\n        caught = caught ? 1 : 0;\n        HEAP8[(this.ptr + 12) >> 0] = caught;\n      };\n      this.get_caught = function () {\n        return HEAP8[(this.ptr + 12) >> 0] != 0;\n      };\n      this.set_rethrown = function (rethrown) {\n        rethrown = rethrown ? 1 : 0;\n        HEAP8[(this.ptr + 13) >> 0] = rethrown;\n      };\n      this.get_rethrown = function () {\n        return HEAP8[(this.ptr + 13) >> 0] != 0;\n      };\n      this.init = function (type, destructor) {\n        this.set_adjusted_ptr(0);\n        this.set_type(type);\n        this.set_destructor(destructor);\n      };\n      this.set_adjusted_ptr = function (adjustedPtr) {\n        HEAPU32[(this.ptr + 16) >> 2] = adjustedPtr;\n      };\n      this.get_adjusted_ptr = function () {\n        return HEAPU32[(this.ptr + 16) >> 2];\n      };\n      this.get_exception_ptr = function () {\n        var isPointer = ___cxa_is_pointer_type(this.get_type());\n        if (isPointer) {\n          return HEAPU32[this.excPtr >> 2];\n        }\n        var adjusted = this.get_adjusted_ptr();\n        if (adjusted !== 0) return adjusted;\n        return this.excPtr;\n      };\n    }\n\n    var exceptionLast = 0;\n\n    var uncaughtExceptionCount = 0;\n\n    var ___cxa_throw = (ptr, type, destructor) => {\n      var info = new ExceptionInfo(ptr);\n      info.init(type, destructor);\n      exceptionLast = ptr;\n      uncaughtExceptionCount++;\n      throw exceptionLast;\n    };\n\n    var SYSCALLS = {\n      varargs: undefined,\n      get() {\n        var ret = HEAP32[+SYSCALLS.varargs >> 2];\n        SYSCALLS.varargs += 4;\n        return ret;\n      },\n      getp() {\n        return SYSCALLS.get();\n      },\n      getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n    };\n\n    function ___syscall_fcntl64(fd, cmd, varargs) {\n      SYSCALLS.varargs = varargs;\n      return 0;\n    }\n\n    var lengthBytesUTF8 = (str) => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var c = str.charCodeAt(i);\n        if (c <= 127) {\n          len++;\n        } else if (c <= 2047) {\n          len += 2;\n        } else if (c >= 55296 && c <= 57343) {\n          len += 4;\n          ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n\n    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n      if (!(maxBytesToWrite > 0)) return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) {\n          var u1 = str.charCodeAt(++i);\n          u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);\n        }\n        if (u <= 127) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 2047) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 192 | (u >> 6);\n          heap[outIdx++] = 128 | (u & 63);\n        } else if (u <= 65535) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 224 | (u >> 12);\n          heap[outIdx++] = 128 | ((u >> 6) & 63);\n          heap[outIdx++] = 128 | (u & 63);\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          heap[outIdx++] = 240 | (u >> 18);\n          heap[outIdx++] = 128 | ((u >> 12) & 63);\n          heap[outIdx++] = 128 | ((u >> 6) & 63);\n          heap[outIdx++] = 128 | (u & 63);\n        }\n      }\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    };\n\n    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n\n    var ___syscall_getcwd = (buf, size) => {};\n\n    function ___syscall_ioctl(fd, op, varargs) {\n      SYSCALLS.varargs = varargs;\n      return 0;\n    }\n\n    function ___syscall_openat(dirfd, path, flags, varargs) {\n      SYSCALLS.varargs = varargs;\n    }\n\n    var structRegistrations = {};\n\n    var runDestructors = (destructors) => {\n      while (destructors.length) {\n        var ptr = destructors.pop();\n        var del = destructors.pop();\n        del(ptr);\n      }\n    };\n\n    /** @suppress {globalThis} */ function simpleReadValueFromPointer(pointer) {\n      return this['fromWireType'](HEAP32[pointer >> 2]);\n    }\n\n    var awaitingDependencies = {};\n\n    var registeredTypes = {};\n\n    var typeDependencies = {};\n\n    var InternalError;\n\n    var throwInternalError = (message) => {\n      throw new InternalError(message);\n    };\n\n    var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {\n      myTypes.forEach(function (type) {\n        typeDependencies[type] = dependentTypes;\n      });\n      function onComplete(typeConverters) {\n        var myTypeConverters = getTypeConverters(typeConverters);\n        if (myTypeConverters.length !== myTypes.length) {\n          throwInternalError('Mismatched type converter count');\n        }\n        for (var i = 0; i < myTypes.length; ++i) {\n          registerType(myTypes[i], myTypeConverters[i]);\n        }\n      }\n      var typeConverters = new Array(dependentTypes.length);\n      var unregisteredTypes = [];\n      var registered = 0;\n      dependentTypes.forEach((dt, i) => {\n        if (registeredTypes.hasOwnProperty(dt)) {\n          typeConverters[i] = registeredTypes[dt];\n        } else {\n          unregisteredTypes.push(dt);\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\n            awaitingDependencies[dt] = [];\n          }\n          awaitingDependencies[dt].push(() => {\n            typeConverters[i] = registeredTypes[dt];\n            ++registered;\n            if (registered === unregisteredTypes.length) {\n              onComplete(typeConverters);\n            }\n          });\n        }\n      });\n      if (0 === unregisteredTypes.length) {\n        onComplete(typeConverters);\n      }\n    };\n\n    var __embind_finalize_value_object = (structType) => {\n      var reg = structRegistrations[structType];\n      delete structRegistrations[structType];\n      var rawConstructor = reg.rawConstructor;\n      var rawDestructor = reg.rawDestructor;\n      var fieldRecords = reg.fields;\n      var fieldTypes = fieldRecords\n        .map((field) => field.getterReturnType)\n        .concat(fieldRecords.map((field) => field.setterArgumentType));\n      whenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes) => {\n        var fields = {};\n        fieldRecords.forEach((field, i) => {\n          var fieldName = field.fieldName;\n          var getterReturnType = fieldTypes[i];\n          var getter = field.getter;\n          var getterContext = field.getterContext;\n          var setterArgumentType = fieldTypes[i + fieldRecords.length];\n          var setter = field.setter;\n          var setterContext = field.setterContext;\n          fields[fieldName] = {\n            read: (ptr) => getterReturnType['fromWireType'](getter(getterContext, ptr)),\n            write: (ptr, o) => {\n              var destructors = [];\n              setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, o));\n              runDestructors(destructors);\n            },\n          };\n        });\n        return [\n          {\n            name: reg.name,\n            fromWireType: (ptr) => {\n              var rv = {};\n              for (var i in fields) {\n                rv[i] = fields[i].read(ptr);\n              }\n              rawDestructor(ptr);\n              return rv;\n            },\n            toWireType: (destructors, o) => {\n              for (var fieldName in fields) {\n                if (!(fieldName in o)) {\n                  throw new TypeError(`Missing field: \"${fieldName}\"`);\n                }\n              }\n              var ptr = rawConstructor();\n              for (fieldName in fields) {\n                fields[fieldName].write(ptr, o[fieldName]);\n              }\n              if (destructors !== null) {\n                destructors.push(rawDestructor, ptr);\n              }\n              return ptr;\n            },\n            argPackAdvance: GenericWireTypeSize,\n            readValueFromPointer: simpleReadValueFromPointer,\n            destructorFunction: rawDestructor,\n          },\n        ];\n      });\n    };\n\n    var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange) => {};\n\n    var embind_init_charCodes = () => {\n      var codes = new Array(256);\n      for (var i = 0; i < 256; ++i) {\n        codes[i] = String.fromCharCode(i);\n      }\n      embind_charCodes = codes;\n    };\n\n    var embind_charCodes;\n\n    var readLatin1String = (ptr) => {\n      var ret = '';\n      var c = ptr;\n      while (HEAPU8[c]) {\n        ret += embind_charCodes[HEAPU8[c++]];\n      }\n      return ret;\n    };\n\n    var BindingError;\n\n    var throwBindingError = (message) => {\n      throw new BindingError(message);\n    };\n\n    /** @param {Object=} options */ function sharedRegisterType(rawType, registeredInstance, options = {}) {\n      var name = registeredInstance.name;\n      if (!rawType) {\n        throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`);\n      }\n      if (registeredTypes.hasOwnProperty(rawType)) {\n        if (options.ignoreDuplicateRegistrations) {\n          return;\n        } else {\n          throwBindingError(`Cannot register type '${name}' twice`);\n        }\n      }\n      registeredTypes[rawType] = registeredInstance;\n      delete typeDependencies[rawType];\n      if (awaitingDependencies.hasOwnProperty(rawType)) {\n        var callbacks = awaitingDependencies[rawType];\n        delete awaitingDependencies[rawType];\n        callbacks.forEach((cb) => cb());\n      }\n    }\n\n    /** @param {Object=} options */ function registerType(rawType, registeredInstance, options = {}) {\n      if (!('argPackAdvance' in registeredInstance)) {\n        throw new TypeError('registerType registeredInstance requires argPackAdvance');\n      }\n      return sharedRegisterType(rawType, registeredInstance, options);\n    }\n\n    var GenericWireTypeSize = 8;\n\n    /** @suppress {globalThis} */ var __embind_register_bool = (rawType, name, trueValue, falseValue) => {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        fromWireType: function (wt) {\n          return !!wt;\n        },\n        toWireType: function (destructors, o) {\n          return o ? trueValue : falseValue;\n        },\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: function (pointer) {\n          return this['fromWireType'](HEAPU8[pointer]);\n        },\n        destructorFunction: null,\n      });\n    };\n\n    var shallowCopyInternalPointer = (o) => ({\n      count: o.count,\n      deleteScheduled: o.deleteScheduled,\n      preservePointerOnDelete: o.preservePointerOnDelete,\n      ptr: o.ptr,\n      ptrType: o.ptrType,\n      smartPtr: o.smartPtr,\n      smartPtrType: o.smartPtrType,\n    });\n\n    var throwInstanceAlreadyDeleted = (obj) => {\n      function getInstanceTypeName(handle) {\n        return handle.$$.ptrType.registeredClass.name;\n      }\n      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');\n    };\n\n    var finalizationRegistry = false;\n\n    var detachFinalizer = (handle) => {};\n\n    var runDestructor = ($$) => {\n      if ($$.smartPtr) {\n        $$.smartPtrType.rawDestructor($$.smartPtr);\n      } else {\n        $$.ptrType.registeredClass.rawDestructor($$.ptr);\n      }\n    };\n\n    var releaseClassHandle = ($$) => {\n      $$.count.value -= 1;\n      var toDelete = 0 === $$.count.value;\n      if (toDelete) {\n        runDestructor($$);\n      }\n    };\n\n    var downcastPointer = (ptr, ptrClass, desiredClass) => {\n      if (ptrClass === desiredClass) {\n        return ptr;\n      }\n      if (undefined === desiredClass.baseClass) {\n        return null;\n      }\n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n      if (rv === null) {\n        return null;\n      }\n      return desiredClass.downcast(rv);\n    };\n\n    var registeredPointers = {};\n\n    var getInheritedInstanceCount = () => Object.keys(registeredInstances).length;\n\n    var getLiveInheritedInstances = () => {\n      var rv = [];\n      for (var k in registeredInstances) {\n        if (registeredInstances.hasOwnProperty(k)) {\n          rv.push(registeredInstances[k]);\n        }\n      }\n      return rv;\n    };\n\n    var deletionQueue = [];\n\n    var flushPendingDeletes = () => {\n      while (deletionQueue.length) {\n        var obj = deletionQueue.pop();\n        obj.$$.deleteScheduled = false;\n        obj['delete']();\n      }\n    };\n\n    var delayFunction;\n\n    var setDelayFunction = (fn) => {\n      delayFunction = fn;\n      if (deletionQueue.length && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n    };\n\n    var init_embind = () => {\n      Module['getInheritedInstanceCount'] = getInheritedInstanceCount;\n      Module['getLiveInheritedInstances'] = getLiveInheritedInstances;\n      Module['flushPendingDeletes'] = flushPendingDeletes;\n      Module['setDelayFunction'] = setDelayFunction;\n    };\n\n    var registeredInstances = {};\n\n    var getBasestPointer = (class_, ptr) => {\n      if (ptr === undefined) {\n        throwBindingError('ptr should not be undefined');\n      }\n      while (class_.baseClass) {\n        ptr = class_.upcast(ptr);\n        class_ = class_.baseClass;\n      }\n      return ptr;\n    };\n\n    var getInheritedInstance = (class_, ptr) => {\n      ptr = getBasestPointer(class_, ptr);\n      return registeredInstances[ptr];\n    };\n\n    var makeClassHandle = (prototype, record) => {\n      if (!record.ptrType || !record.ptr) {\n        throwInternalError('makeClassHandle requires ptr and ptrType');\n      }\n      var hasSmartPtrType = !!record.smartPtrType;\n      var hasSmartPtr = !!record.smartPtr;\n      if (hasSmartPtrType !== hasSmartPtr) {\n        throwInternalError('Both smartPtrType and smartPtr must be specified');\n      }\n      record.count = {\n        value: 1,\n      };\n      return attachFinalizer(\n        Object.create(prototype, {\n          $$: {\n            value: record,\n            writable: true,\n          },\n        }),\n      );\n    };\n\n    /** @suppress {globalThis} */ function RegisteredPointer_fromWireType(ptr) {\n      var rawPointer = this.getPointee(ptr);\n      if (!rawPointer) {\n        this.destructor(ptr);\n        return null;\n      }\n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n      if (undefined !== registeredInstance) {\n        if (0 === registeredInstance.$$.count.value) {\n          registeredInstance.$$.ptr = rawPointer;\n          registeredInstance.$$.smartPtr = ptr;\n          return registeredInstance['clone']();\n        } else {\n          var rv = registeredInstance['clone']();\n          this.destructor(ptr);\n          return rv;\n        }\n      }\n      function makeDefaultHandle() {\n        if (this.isSmartPointer) {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this.pointeeType,\n            ptr: rawPointer,\n            smartPtrType: this,\n            smartPtr: ptr,\n          });\n        } else {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this,\n            ptr: ptr,\n          });\n        }\n      }\n      var actualType = this.registeredClass.getActualType(rawPointer);\n      var registeredPointerRecord = registeredPointers[actualType];\n      if (!registeredPointerRecord) {\n        return makeDefaultHandle.call(this);\n      }\n      var toType;\n      if (this.isConst) {\n        toType = registeredPointerRecord.constPointerType;\n      } else {\n        toType = registeredPointerRecord.pointerType;\n      }\n      var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n      if (dp === null) {\n        return makeDefaultHandle.call(this);\n      }\n      if (this.isSmartPointer) {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp,\n          smartPtrType: this,\n          smartPtr: ptr,\n        });\n      } else {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp,\n        });\n      }\n    }\n\n    var attachFinalizer = (handle) => {\n      if ('undefined' === typeof FinalizationRegistry) {\n        attachFinalizer = (handle) => handle;\n        return handle;\n      }\n      finalizationRegistry = new FinalizationRegistry((info) => {\n        releaseClassHandle(info.$$);\n      });\n      attachFinalizer = (handle) => {\n        var $$ = handle.$$;\n        var hasSmartPtr = !!$$.smartPtr;\n        if (hasSmartPtr) {\n          var info = {\n            $$: $$,\n          };\n          finalizationRegistry.register(handle, info, handle);\n        }\n        return handle;\n      };\n      detachFinalizer = (handle) => finalizationRegistry.unregister(handle);\n      return attachFinalizer(handle);\n    };\n\n    var init_ClassHandle = () => {\n      Object.assign(ClassHandle.prototype, {\n        isAliasOf(other) {\n          if (!(this instanceof ClassHandle)) {\n            return false;\n          }\n          if (!(other instanceof ClassHandle)) {\n            return false;\n          }\n          var leftClass = this.$$.ptrType.registeredClass;\n          var left = this.$$.ptr;\n          other.$$ = /** @type {Object} */ (other.$$);\n          var rightClass = other.$$.ptrType.registeredClass;\n          var right = other.$$.ptr;\n          while (leftClass.baseClass) {\n            left = leftClass.upcast(left);\n            leftClass = leftClass.baseClass;\n          }\n          while (rightClass.baseClass) {\n            right = rightClass.upcast(right);\n            rightClass = rightClass.baseClass;\n          }\n          return leftClass === rightClass && left === right;\n        },\n        clone() {\n          if (!this.$$.ptr) {\n            throwInstanceAlreadyDeleted(this);\n          }\n          if (this.$$.preservePointerOnDelete) {\n            this.$$.count.value += 1;\n            return this;\n          } else {\n            var clone = attachFinalizer(\n              Object.create(Object.getPrototypeOf(this), {\n                $$: {\n                  value: shallowCopyInternalPointer(this.$$),\n                },\n              }),\n            );\n            clone.$$.count.value += 1;\n            clone.$$.deleteScheduled = false;\n            return clone;\n          }\n        },\n        delete() {\n          if (!this.$$.ptr) {\n            throwInstanceAlreadyDeleted(this);\n          }\n          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n            throwBindingError('Object already scheduled for deletion');\n          }\n          detachFinalizer(this);\n          releaseClassHandle(this.$$);\n          if (!this.$$.preservePointerOnDelete) {\n            this.$$.smartPtr = undefined;\n            this.$$.ptr = undefined;\n          }\n        },\n        isDeleted() {\n          return !this.$$.ptr;\n        },\n        deleteLater() {\n          if (!this.$$.ptr) {\n            throwInstanceAlreadyDeleted(this);\n          }\n          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n            throwBindingError('Object already scheduled for deletion');\n          }\n          deletionQueue.push(this);\n          if (deletionQueue.length === 1 && delayFunction) {\n            delayFunction(flushPendingDeletes);\n          }\n          this.$$.deleteScheduled = true;\n          return this;\n        },\n      });\n    };\n\n    /** @constructor */ function ClassHandle() {}\n\n    var createNamedFunction = (name, body) =>\n      Object.defineProperty(body, 'name', {\n        value: name,\n      });\n\n    var ensureOverloadTable = (proto, methodName, humanName) => {\n      if (undefined === proto[methodName].overloadTable) {\n        var prevFunc = proto[methodName];\n        proto[methodName] = function () {\n          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n            throwBindingError(\n              `Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`,\n            );\n          }\n          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n        };\n        proto[methodName].overloadTable = [];\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n      }\n    };\n\n    /** @param {number=} numArguments */ var exposePublicSymbol = (name, value, numArguments) => {\n      if (Module.hasOwnProperty(name)) {\n        if (\n          undefined === numArguments ||\n          (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])\n        ) {\n          throwBindingError(`Cannot register public name '${name}' twice`);\n        }\n        ensureOverloadTable(Module, name, name);\n        if (Module.hasOwnProperty(numArguments)) {\n          throwBindingError(\n            `Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`,\n          );\n        }\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        if (undefined !== numArguments) {\n          Module[name].numArguments = numArguments;\n        }\n      }\n    };\n\n    var char_0 = 48;\n\n    var char_9 = 57;\n\n    var makeLegalFunctionName = (name) => {\n      if (undefined === name) {\n        return '_unknown';\n      }\n      name = name.replace(/[^a-zA-Z0-9_]/g, '$');\n      var f = name.charCodeAt(0);\n      if (f >= char_0 && f <= char_9) {\n        return `_${name}`;\n      }\n      return name;\n    };\n\n    /** @constructor */ function RegisteredClass(\n      name,\n      constructor,\n      instancePrototype,\n      rawDestructor,\n      baseClass,\n      getActualType,\n      upcast,\n      downcast,\n    ) {\n      this.name = name;\n      this.constructor = constructor;\n      this.instancePrototype = instancePrototype;\n      this.rawDestructor = rawDestructor;\n      this.baseClass = baseClass;\n      this.getActualType = getActualType;\n      this.upcast = upcast;\n      this.downcast = downcast;\n      this.pureVirtualFunctions = [];\n    }\n\n    var upcastPointer = (ptr, ptrClass, desiredClass) => {\n      while (ptrClass !== desiredClass) {\n        if (!ptrClass.upcast) {\n          throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);\n        }\n        ptr = ptrClass.upcast(ptr);\n        ptrClass = ptrClass.baseClass;\n      }\n      return ptr;\n    };\n\n    /** @suppress {globalThis} */ function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(`null is not a valid ${this.name}`);\n        }\n        return 0;\n      }\n      if (!handle.$$) {\n        throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n\n    /** @suppress {globalThis} */ function genericPointerToWireType(destructors, handle) {\n      var ptr;\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(`null is not a valid ${this.name}`);\n        }\n        if (this.isSmartPointer) {\n          ptr = this.rawConstructor();\n          if (destructors !== null) {\n            destructors.push(this.rawDestructor, ptr);\n          }\n          return ptr;\n        } else {\n          return 0;\n        }\n      }\n      if (!handle || !handle.$$) {\n        throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n      }\n      if (!this.isConst && handle.$$.ptrType.isConst) {\n        throwBindingError(\n          `Cannot convert argument of type ${\n            handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name\n          } to parameter type ${this.name}`,\n        );\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      if (this.isSmartPointer) {\n        if (undefined === handle.$$.smartPtr) {\n          throwBindingError('Passing raw pointer to smart pointer is illegal');\n        }\n        switch (this.sharingPolicy) {\n          case 0:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              throwBindingError(\n                `Cannot convert argument of type ${\n                  handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name\n                } to parameter type ${this.name}`,\n              );\n            }\n            break;\n\n          case 1:\n            ptr = handle.$$.smartPtr;\n            break;\n\n          case 2:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              var clonedHandle = handle['clone']();\n              ptr = this.rawShare(\n                ptr,\n                Emval.toHandle(() => clonedHandle['delete']()),\n              );\n              if (destructors !== null) {\n                destructors.push(this.rawDestructor, ptr);\n              }\n            }\n            break;\n\n          default:\n            throwBindingError('Unsupporting sharing policy');\n        }\n      }\n      return ptr;\n    }\n\n    /** @suppress {globalThis} */ function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(`null is not a valid ${this.name}`);\n        }\n        return 0;\n      }\n      if (!handle.$$) {\n        throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\n      }\n      if (handle.$$.ptrType.isConst) {\n        throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n\n    /** @suppress {globalThis} */ function readPointer(pointer) {\n      return this['fromWireType'](HEAPU32[pointer >> 2]);\n    }\n\n    var init_RegisteredPointer = () => {\n      Object.assign(RegisteredPointer.prototype, {\n        getPointee(ptr) {\n          if (this.rawGetPointee) {\n            ptr = this.rawGetPointee(ptr);\n          }\n          return ptr;\n        },\n        destructor(ptr) {\n          this.rawDestructor?.(ptr);\n        },\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: readPointer,\n        deleteObject(handle) {\n          if (handle !== null) {\n            handle['delete']();\n          }\n        },\n        fromWireType: RegisteredPointer_fromWireType,\n      });\n    };\n\n    /** @constructor\n      @param {*=} pointeeType,\n      @param {*=} sharingPolicy,\n      @param {*=} rawGetPointee,\n      @param {*=} rawConstructor,\n      @param {*=} rawShare,\n      @param {*=} rawDestructor,\n       */ function RegisteredPointer(\n      name,\n      registeredClass,\n      isReference,\n      isConst,\n      isSmartPointer,\n      pointeeType,\n      sharingPolicy,\n      rawGetPointee,\n      rawConstructor,\n      rawShare,\n      rawDestructor,\n    ) {\n      this.name = name;\n      this.registeredClass = registeredClass;\n      this.isReference = isReference;\n      this.isConst = isConst;\n      this.isSmartPointer = isSmartPointer;\n      this.pointeeType = pointeeType;\n      this.sharingPolicy = sharingPolicy;\n      this.rawGetPointee = rawGetPointee;\n      this.rawConstructor = rawConstructor;\n      this.rawShare = rawShare;\n      this.rawDestructor = rawDestructor;\n      if (!isSmartPointer && registeredClass.baseClass === undefined) {\n        if (isConst) {\n          this['toWireType'] = constNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        } else {\n          this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        }\n      } else {\n        this['toWireType'] = genericPointerToWireType;\n      }\n    }\n\n    /** @param {number=} numArguments */ var replacePublicSymbol = (name, value, numArguments) => {\n      if (!Module.hasOwnProperty(name)) {\n        throwInternalError('Replacing nonexistant public symbol');\n      }\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        Module[name].argCount = numArguments;\n      }\n    };\n\n    var dynCallLegacy = (sig, ptr, args) => {\n      var f = Module['dynCall_' + sig];\n      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);\n    };\n\n    var wasmTable;\n\n    var getWasmTableEntry = (funcPtr) => wasmTable.get(funcPtr);\n\n    /** @param {Object=} args */ var dynCall = (sig, ptr, args) => {\n      if (sig.includes('j')) {\n        return dynCallLegacy(sig, ptr, args);\n      }\n      var rtn = getWasmTableEntry(ptr).apply(null, args);\n      return rtn;\n    };\n\n    var getDynCaller = (sig, ptr) => {\n      var argCache = [];\n      return function () {\n        argCache.length = 0;\n        Object.assign(argCache, arguments);\n        return dynCall(sig, ptr, argCache);\n      };\n    };\n\n    var embind__requireFunction = (signature, rawFunction) => {\n      signature = readLatin1String(signature);\n      function makeDynCaller() {\n        if (signature.includes('j')) {\n          return getDynCaller(signature, rawFunction);\n        }\n        return getWasmTableEntry(rawFunction);\n      }\n      var fp = makeDynCaller();\n      if (typeof fp != 'function') {\n        throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);\n      }\n      return fp;\n    };\n\n    var extendError = (baseErrorType, errorName) => {\n      var errorClass = createNamedFunction(errorName, function (message) {\n        this.name = errorName;\n        this.message = message;\n        var stack = new Error(message).stack;\n        if (stack !== undefined) {\n          this.stack = this.toString() + '\\n' + stack.replace(/^Error(:[^\\n]*)?\\n/, '');\n        }\n      });\n      errorClass.prototype = Object.create(baseErrorType.prototype);\n      errorClass.prototype.constructor = errorClass;\n      errorClass.prototype.toString = function () {\n        if (this.message === undefined) {\n          return this.name;\n        } else {\n          return `${this.name}: ${this.message}`;\n        }\n      };\n      return errorClass;\n    };\n\n    var UnboundTypeError;\n\n    var getTypeName = (type) => {\n      var ptr = ___getTypeName(type);\n      var rv = readLatin1String(ptr);\n      _free(ptr);\n      return rv;\n    };\n\n    var throwUnboundTypeError = (message, types) => {\n      var unboundTypes = [];\n      var seen = {};\n      function visit(type) {\n        if (seen[type]) {\n          return;\n        }\n        if (registeredTypes[type]) {\n          return;\n        }\n        if (typeDependencies[type]) {\n          typeDependencies[type].forEach(visit);\n          return;\n        }\n        unboundTypes.push(type);\n        seen[type] = true;\n      }\n      types.forEach(visit);\n      throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([', ']));\n    };\n\n    var __embind_register_class = (\n      rawType,\n      rawPointerType,\n      rawConstPointerType,\n      baseClassRawType,\n      getActualTypeSignature,\n      getActualType,\n      upcastSignature,\n      upcast,\n      downcastSignature,\n      downcast,\n      name,\n      destructorSignature,\n      rawDestructor,\n    ) => {\n      name = readLatin1String(name);\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n      upcast &&= embind__requireFunction(upcastSignature, upcast);\n      downcast &&= embind__requireFunction(downcastSignature, downcast);\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n      var legalFunctionName = makeLegalFunctionName(name);\n      exposePublicSymbol(legalFunctionName, function () {\n        throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [baseClassRawType]);\n      });\n      whenDependentTypesAreResolved(\n        [rawType, rawPointerType, rawConstPointerType],\n        baseClassRawType ? [baseClassRawType] : [],\n        function (base) {\n          base = base[0];\n          var baseClass;\n          var basePrototype;\n          if (baseClassRawType) {\n            baseClass = base.registeredClass;\n            basePrototype = baseClass.instancePrototype;\n          } else {\n            basePrototype = ClassHandle.prototype;\n          }\n          var constructor = createNamedFunction(name, function () {\n            if (Object.getPrototypeOf(this) !== instancePrototype) {\n              throw new BindingError(\"Use 'new' to construct \" + name);\n            }\n            if (undefined === registeredClass.constructor_body) {\n              throw new BindingError(name + ' has no accessible constructor');\n            }\n            var body = registeredClass.constructor_body[arguments.length];\n            if (undefined === body) {\n              throw new BindingError(\n                `Tried to invoke ctor of ${name} with invalid number of parameters (${\n                  arguments.length\n                }) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`,\n              );\n            }\n            return body.apply(this, arguments);\n          });\n          var instancePrototype = Object.create(basePrototype, {\n            constructor: {\n              value: constructor,\n            },\n          });\n          constructor.prototype = instancePrototype;\n          var registeredClass = new RegisteredClass(\n            name,\n            constructor,\n            instancePrototype,\n            rawDestructor,\n            baseClass,\n            getActualType,\n            upcast,\n            downcast,\n          );\n          if (registeredClass.baseClass) {\n            registeredClass.baseClass.__derivedClasses ??= [];\n            registeredClass.baseClass.__derivedClasses.push(registeredClass);\n          }\n          var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n          var pointerConverter = new RegisteredPointer(name + '*', registeredClass, false, false, false);\n          var constPointerConverter = new RegisteredPointer(name + ' const*', registeredClass, false, true, false);\n          registeredPointers[rawType] = {\n            pointerType: pointerConverter,\n            constPointerType: constPointerConverter,\n          };\n          replacePublicSymbol(legalFunctionName, constructor);\n          return [referenceConverter, pointerConverter, constPointerConverter];\n        },\n      );\n    };\n\n    var heap32VectorToArray = (count, firstElement) => {\n      var array = [];\n      for (var i = 0; i < count; i++) {\n        array.push(HEAPU32[(firstElement + i * 4) >> 2]);\n      }\n      return array;\n    };\n\n    function usesDestructorStack(argTypes) {\n      for (var i = 1; i < argTypes.length; ++i) {\n        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    function craftInvokerFunction(\n      humanName,\n      argTypes,\n      classType,\n      cppInvokerFunc,\n      cppTargetFunc,\n      /** boolean= */ isAsync,\n    ) {\n      var argCount = argTypes.length;\n      if (argCount < 2) {\n        throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n      }\n      var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n      var needsDestructorStack = usesDestructorStack(argTypes);\n      var returns = argTypes[0].name !== 'void';\n      var expectedArgCount = argCount - 2;\n      var argsWired = new Array(expectedArgCount);\n      var invokerFuncArgs = [];\n      var destructors = [];\n      var invokerFn = function () {\n        if (arguments.length !== expectedArgCount) {\n          throwBindingError(\n            `function ${humanName} called with ${arguments.length} arguments, expected ${expectedArgCount}`,\n          );\n        }\n        destructors.length = 0;\n        var thisWired;\n        invokerFuncArgs.length = isClassMethodFunc ? 2 : 1;\n        invokerFuncArgs[0] = cppTargetFunc;\n        if (isClassMethodFunc) {\n          thisWired = argTypes[1]['toWireType'](destructors, this);\n          invokerFuncArgs[1] = thisWired;\n        }\n        for (var i = 0; i < expectedArgCount; ++i) {\n          argsWired[i] = argTypes[i + 2]['toWireType'](destructors, arguments[i]);\n          invokerFuncArgs.push(argsWired[i]);\n        }\n        var rv = cppInvokerFunc.apply(null, invokerFuncArgs);\n        function onDone(rv) {\n          if (needsDestructorStack) {\n            runDestructors(destructors);\n          } else {\n            for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; i++) {\n              var param = i === 1 ? thisWired : argsWired[i - 2];\n              if (argTypes[i].destructorFunction !== null) {\n                argTypes[i].destructorFunction(param);\n              }\n            }\n          }\n          if (returns) {\n            return argTypes[0]['fromWireType'](rv);\n          }\n        }\n        return onDone(rv);\n      };\n      return createNamedFunction(humanName, invokerFn);\n    }\n\n    var __embind_register_class_constructor = (\n      rawClassType,\n      argCount,\n      rawArgTypesAddr,\n      invokerSignature,\n      invoker,\n      rawConstructor,\n    ) => {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      invoker = embind__requireFunction(invokerSignature, invoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = `constructor ${classType.name}`;\n        if (undefined === classType.registeredClass.constructor_body) {\n          classType.registeredClass.constructor_body = [];\n        }\n        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n          throw new BindingError(\n            `Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${\n              classType.name\n            }'! Overload resolution is currently only performed using the parameter count, not actual type info!`,\n          );\n        }\n        classType.registeredClass.constructor_body[argCount - 1] = () => {\n          throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);\n        };\n        whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {\n          argTypes.splice(1, 0, null);\n          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(\n            humanName,\n            argTypes,\n            null,\n            invoker,\n            rawConstructor,\n          );\n          return [];\n        });\n        return [];\n      });\n    };\n\n    var getFunctionName = (signature) => {\n      signature = signature.trim();\n      const argsIndex = signature.indexOf('(');\n      if (argsIndex !== -1) {\n        return signature.substr(0, argsIndex);\n      } else {\n        return signature;\n      }\n    };\n\n    var __embind_register_class_function = (\n      rawClassType,\n      methodName,\n      argCount,\n      rawArgTypesAddr,\n      invokerSignature,\n      rawInvoker,\n      context,\n      isPureVirtual,\n      isAsync,\n    ) => {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      methodName = readLatin1String(methodName);\n      methodName = getFunctionName(methodName);\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = `${classType.name}.${methodName}`;\n        if (methodName.startsWith('@@')) {\n          methodName = Symbol[methodName.substring(2)];\n        }\n        if (isPureVirtual) {\n          classType.registeredClass.pureVirtualFunctions.push(methodName);\n        }\n        function unboundTypesHandler() {\n          throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);\n        }\n        var proto = classType.registeredClass.instancePrototype;\n        var method = proto[methodName];\n        if (\n          undefined === method ||\n          (undefined === method.overloadTable &&\n            method.className !== classType.name &&\n            method.argCount === argCount - 2)\n        ) {\n          unboundTypesHandler.argCount = argCount - 2;\n          unboundTypesHandler.className = classType.name;\n          proto[methodName] = unboundTypesHandler;\n        } else {\n          ensureOverloadTable(proto, methodName, humanName);\n          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n        }\n        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);\n          if (undefined === proto[methodName].overloadTable) {\n            memberFunction.argCount = argCount - 2;\n            proto[methodName] = memberFunction;\n          } else {\n            proto[methodName].overloadTable[argCount - 2] = memberFunction;\n          }\n          return [];\n        });\n        return [];\n      });\n    };\n\n    function handleAllocatorInit() {\n      Object.assign(\n        HandleAllocator.prototype,\n        /** @lends {HandleAllocator.prototype} */ {\n          get(id) {\n            return this.allocated[id];\n          },\n          has(id) {\n            return this.allocated[id] !== undefined;\n          },\n          allocate(handle) {\n            var id = this.freelist.pop() || this.allocated.length;\n            this.allocated[id] = handle;\n            return id;\n          },\n          free(id) {\n            this.allocated[id] = undefined;\n            this.freelist.push(id);\n          },\n        },\n      );\n    }\n\n    /** @constructor */ function HandleAllocator() {\n      this.allocated = [undefined];\n      this.freelist = [];\n    }\n\n    var emval_handles = new HandleAllocator();\n\n    var __emval_decref = (handle) => {\n      if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) {\n        emval_handles.free(handle);\n      }\n    };\n\n    var count_emval_handles = () => {\n      var count = 0;\n      for (var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i) {\n        if (emval_handles.allocated[i] !== undefined) {\n          ++count;\n        }\n      }\n      return count;\n    };\n\n    var init_emval = () => {\n      emval_handles.allocated.push(\n        {\n          value: undefined,\n        },\n        {\n          value: null,\n        },\n        {\n          value: true,\n        },\n        {\n          value: false,\n        },\n      );\n      emval_handles.reserved = emval_handles.allocated.length;\n      Module['count_emval_handles'] = count_emval_handles;\n    };\n\n    var Emval = {\n      toValue: (handle) => {\n        if (!handle) {\n          throwBindingError('Cannot use deleted val. handle = ' + handle);\n        }\n        return emval_handles.get(handle).value;\n      },\n      toHandle: (value) => {\n        switch (value) {\n          case undefined:\n            return 1;\n\n          case null:\n            return 2;\n\n          case true:\n            return 3;\n\n          case false:\n            return 4;\n\n          default: {\n            return emval_handles.allocate({\n              refcount: 1,\n              value: value,\n            });\n          }\n        }\n      },\n    };\n\n    var __embind_register_emval = (rawType, name) => {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        fromWireType: (handle) => {\n          var rv = Emval.toValue(handle);\n          __emval_decref(handle);\n          return rv;\n        },\n        toWireType: (destructors, value) => Emval.toHandle(value),\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: simpleReadValueFromPointer,\n        destructorFunction: null,\n      });\n    };\n\n    var enumReadValueFromPointer = (name, width, signed) => {\n      switch (width) {\n        case 1:\n          return signed\n            ? function (pointer) {\n                return this['fromWireType'](HEAP8[pointer >> 0]);\n              }\n            : function (pointer) {\n                return this['fromWireType'](HEAPU8[pointer >> 0]);\n              };\n\n        case 2:\n          return signed\n            ? function (pointer) {\n                return this['fromWireType'](HEAP16[pointer >> 1]);\n              }\n            : function (pointer) {\n                return this['fromWireType'](HEAPU16[pointer >> 1]);\n              };\n\n        case 4:\n          return signed\n            ? function (pointer) {\n                return this['fromWireType'](HEAP32[pointer >> 2]);\n              }\n            : function (pointer) {\n                return this['fromWireType'](HEAPU32[pointer >> 2]);\n              };\n\n        default:\n          throw new TypeError(`invalid integer width (${width}): ${name}`);\n      }\n    };\n\n    /** @suppress {globalThis} */ var __embind_register_enum = (rawType, name, size, isSigned) => {\n      name = readLatin1String(name);\n      function ctor() {}\n      ctor.values = {};\n      registerType(rawType, {\n        name: name,\n        constructor: ctor,\n        fromWireType: function (c) {\n          return this.constructor.values[c];\n        },\n        toWireType: (destructors, c) => c.value,\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: enumReadValueFromPointer(name, size, isSigned),\n        destructorFunction: null,\n      });\n      exposePublicSymbol(name, ctor);\n    };\n\n    var requireRegisteredType = (rawType, humanName) => {\n      var impl = registeredTypes[rawType];\n      if (undefined === impl) {\n        throwBindingError(humanName + ' has unknown type ' + getTypeName(rawType));\n      }\n      return impl;\n    };\n\n    var __embind_register_enum_value = (rawEnumType, name, enumValue) => {\n      var enumType = requireRegisteredType(rawEnumType, 'enum');\n      name = readLatin1String(name);\n      var Enum = enumType.constructor;\n      var Value = Object.create(enumType.constructor.prototype, {\n        value: {\n          value: enumValue,\n        },\n        constructor: {\n          value: createNamedFunction(`${enumType.name}_${name}`, function () {}),\n        },\n      });\n      Enum.values[enumValue] = Value;\n      Enum[name] = Value;\n    };\n\n    var embindRepr = (v) => {\n      if (v === null) {\n        return 'null';\n      }\n      var t = typeof v;\n      if (t === 'object' || t === 'array' || t === 'function') {\n        return v.toString();\n      } else {\n        return '' + v;\n      }\n    };\n\n    var floatReadValueFromPointer = (name, width) => {\n      switch (width) {\n        case 4:\n          return function (pointer) {\n            return this['fromWireType'](HEAPF32[pointer >> 2]);\n          };\n\n        case 8:\n          return function (pointer) {\n            return this['fromWireType'](HEAPF64[pointer >> 3]);\n          };\n\n        default:\n          throw new TypeError(`invalid float width (${width}): ${name}`);\n      }\n    };\n\n    var __embind_register_float = (rawType, name, size) => {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        fromWireType: (value) => value,\n        toWireType: (destructors, value) => value,\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: floatReadValueFromPointer(name, size),\n        destructorFunction: null,\n      });\n    };\n\n    var integerReadValueFromPointer = (name, width, signed) => {\n      switch (width) {\n        case 1:\n          return signed ? (pointer) => HEAP8[pointer >> 0] : (pointer) => HEAPU8[pointer >> 0];\n\n        case 2:\n          return signed ? (pointer) => HEAP16[pointer >> 1] : (pointer) => HEAPU16[pointer >> 1];\n\n        case 4:\n          return signed ? (pointer) => HEAP32[pointer >> 2] : (pointer) => HEAPU32[pointer >> 2];\n\n        default:\n          throw new TypeError(`invalid integer width (${width}): ${name}`);\n      }\n    };\n\n    /** @suppress {globalThis} */ var __embind_register_integer = (primitiveType, name, size, minRange, maxRange) => {\n      name = readLatin1String(name);\n      if (maxRange === -1) {\n        maxRange = 4294967295;\n      }\n      var fromWireType = (value) => value;\n      if (minRange === 0) {\n        var bitshift = 32 - 8 * size;\n        fromWireType = (value) => (value << bitshift) >>> bitshift;\n      }\n      var isUnsignedType = name.includes('unsigned');\n      var checkAssertions = (value, toTypeName) => {};\n      var toWireType;\n      if (isUnsignedType) {\n        toWireType = function (destructors, value) {\n          checkAssertions(value, this.name);\n          return value >>> 0;\n        };\n      } else {\n        toWireType = function (destructors, value) {\n          checkAssertions(value, this.name);\n          return value;\n        };\n      }\n      registerType(primitiveType, {\n        name: name,\n        fromWireType: fromWireType,\n        toWireType: toWireType,\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: integerReadValueFromPointer(name, size, minRange !== 0),\n        destructorFunction: null,\n      });\n    };\n\n    var __embind_register_memory_view = (rawType, dataTypeIndex, name) => {\n      var typeMapping = [\n        Int8Array,\n        Uint8Array,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n        Float32Array,\n        Float64Array,\n      ];\n      var TA = typeMapping[dataTypeIndex];\n      function decodeMemoryView(handle) {\n        var size = HEAPU32[handle >> 2];\n        var data = HEAPU32[(handle + 4) >> 2];\n        return new TA(HEAP8.buffer, data, size);\n      }\n      name = readLatin1String(name);\n      registerType(\n        rawType,\n        {\n          name: name,\n          fromWireType: decodeMemoryView,\n          argPackAdvance: GenericWireTypeSize,\n          readValueFromPointer: decodeMemoryView,\n        },\n        {\n          ignoreDuplicateRegistrations: true,\n        },\n      );\n    };\n\n    var __embind_register_smart_ptr = (\n      rawType,\n      rawPointeeType,\n      name,\n      sharingPolicy,\n      getPointeeSignature,\n      rawGetPointee,\n      constructorSignature,\n      rawConstructor,\n      shareSignature,\n      rawShare,\n      destructorSignature,\n      rawDestructor,\n    ) => {\n      name = readLatin1String(name);\n      rawGetPointee = embind__requireFunction(getPointeeSignature, rawGetPointee);\n      rawConstructor = embind__requireFunction(constructorSignature, rawConstructor);\n      rawShare = embind__requireFunction(shareSignature, rawShare);\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n      whenDependentTypesAreResolved([rawType], [rawPointeeType], function (pointeeType) {\n        pointeeType = pointeeType[0];\n        var registeredPointer = new RegisteredPointer(\n          name,\n          pointeeType.registeredClass,\n          false,\n          false,\n          true,\n          pointeeType,\n          sharingPolicy,\n          rawGetPointee,\n          rawConstructor,\n          rawShare,\n          rawDestructor,\n        );\n        return [registeredPointer];\n      });\n    };\n\n    var __embind_register_std_string = (rawType, name) => {\n      name = readLatin1String(name);\n      var stdStringIsUTF8 = name === 'std::string';\n      registerType(rawType, {\n        name: name,\n        fromWireType(value) {\n          var length = HEAPU32[value >> 2];\n          var payload = value + 4;\n          var str;\n          if (stdStringIsUTF8) {\n            var decodeStartPtr = payload;\n            for (var i = 0; i <= length; ++i) {\n              var currentBytePtr = payload + i;\n              if (i == length || HEAPU8[currentBytePtr] == 0) {\n                var maxRead = currentBytePtr - decodeStartPtr;\n                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                if (str === undefined) {\n                  str = stringSegment;\n                } else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n                decodeStartPtr = currentBytePtr + 1;\n              }\n            }\n          } else {\n            var a = new Array(length);\n            for (var i = 0; i < length; ++i) {\n              a[i] = String.fromCharCode(HEAPU8[payload + i]);\n            }\n            str = a.join('');\n          }\n          _free(value);\n          return str;\n        },\n        toWireType(destructors, value) {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n          var length;\n          var valueIsOfTypeString = typeof value == 'string';\n          if (\n            !(\n              valueIsOfTypeString ||\n              value instanceof Uint8Array ||\n              value instanceof Uint8ClampedArray ||\n              value instanceof Int8Array\n            )\n          ) {\n            throwBindingError('Cannot pass non-string to std::string');\n          }\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            length = lengthBytesUTF8(value);\n          } else {\n            length = value.length;\n          }\n          var base = _malloc(4 + length + 1);\n          var ptr = base + 4;\n          HEAPU32[base >> 2] = length;\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            stringToUTF8(value, ptr, length + 1);\n          } else {\n            if (valueIsOfTypeString) {\n              for (var i = 0; i < length; ++i) {\n                var charCode = value.charCodeAt(i);\n                if (charCode > 255) {\n                  _free(ptr);\n                  throwBindingError('String has UTF-16 code units that do not fit in 8 bits');\n                }\n                HEAPU8[ptr + i] = charCode;\n              }\n            } else {\n              for (var i = 0; i < length; ++i) {\n                HEAPU8[ptr + i] = value[i];\n              }\n            }\n          }\n          if (destructors !== null) {\n            destructors.push(_free, base);\n          }\n          return base;\n        },\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: readPointer,\n        destructorFunction(ptr) {\n          _free(ptr);\n        },\n      });\n    };\n\n    var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\n    var UTF16ToString = (ptr, maxBytesToRead) => {\n      var endPtr = ptr;\n      var idx = endPtr >> 1;\n      var maxIdx = idx + maxBytesToRead / 2;\n      while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\n      endPtr = idx << 1;\n      if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      var str = '';\n      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n        var codeUnit = HEAP16[(ptr + i * 2) >> 1];\n        if (codeUnit == 0) break;\n        str += String.fromCharCode(codeUnit);\n      }\n      return str;\n    };\n\n    var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\n      maxBytesToWrite ??= 2147483647;\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2;\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      }\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    };\n\n    var lengthBytesUTF16 = (str) => str.length * 2;\n\n    var UTF32ToString = (ptr, maxBytesToRead) => {\n      var i = 0;\n      var str = '';\n      while (!(i >= maxBytesToRead / 4)) {\n        var utf32 = HEAP32[(ptr + i * 4) >> 2];\n        if (utf32 == 0) break;\n        ++i;\n        if (utf32 >= 65536) {\n          var ch = utf32 - 65536;\n          str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n      return str;\n    };\n\n    var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {\n      maxBytesToWrite ??= 2147483647;\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit = (65536 + ((codeUnit & 1023) << 10)) | (trailSurrogate & 1023);\n        }\n        HEAP32[outPtr >> 2] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      }\n      HEAP32[outPtr >> 2] = 0;\n      return outPtr - startPtr;\n    };\n\n    var lengthBytesUTF32 = (str) => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n        len += 4;\n      }\n      return len;\n    };\n\n    var __embind_register_std_wstring = (rawType, charSize, name) => {\n      name = readLatin1String(name);\n      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n      if (charSize === 2) {\n        decodeString = UTF16ToString;\n        encodeString = stringToUTF16;\n        lengthBytesUTF = lengthBytesUTF16;\n        getHeap = () => HEAPU16;\n        shift = 1;\n      } else if (charSize === 4) {\n        decodeString = UTF32ToString;\n        encodeString = stringToUTF32;\n        lengthBytesUTF = lengthBytesUTF32;\n        getHeap = () => HEAPU32;\n        shift = 2;\n      }\n      registerType(rawType, {\n        name: name,\n        fromWireType: (value) => {\n          var length = HEAPU32[value >> 2];\n          var HEAP = getHeap();\n          var str;\n          var decodeStartPtr = value + 4;\n          for (var i = 0; i <= length; ++i) {\n            var currentBytePtr = value + 4 + i * charSize;\n            if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n              if (str === undefined) {\n                str = stringSegment;\n              } else {\n                str += String.fromCharCode(0);\n                str += stringSegment;\n              }\n              decodeStartPtr = currentBytePtr + charSize;\n            }\n          }\n          _free(value);\n          return str;\n        },\n        toWireType: (destructors, value) => {\n          if (!(typeof value == 'string')) {\n            throwBindingError(`Cannot pass non-string to C++ string type ${name}`);\n          }\n          var length = lengthBytesUTF(value);\n          var ptr = _malloc(4 + length + charSize);\n          HEAPU32[ptr >> 2] = length >> shift;\n          encodeString(value, ptr + 4, length + charSize);\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        },\n        argPackAdvance: GenericWireTypeSize,\n        readValueFromPointer: simpleReadValueFromPointer,\n        destructorFunction(ptr) {\n          _free(ptr);\n        },\n      });\n    };\n\n    var __embind_register_value_object = (\n      rawType,\n      name,\n      constructorSignature,\n      rawConstructor,\n      destructorSignature,\n      rawDestructor,\n    ) => {\n      structRegistrations[rawType] = {\n        name: readLatin1String(name),\n        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n        fields: [],\n      };\n    };\n\n    var __embind_register_value_object_field = (\n      structType,\n      fieldName,\n      getterReturnType,\n      getterSignature,\n      getter,\n      getterContext,\n      setterArgumentType,\n      setterSignature,\n      setter,\n      setterContext,\n    ) => {\n      structRegistrations[structType].fields.push({\n        fieldName: readLatin1String(fieldName),\n        getterReturnType: getterReturnType,\n        getter: embind__requireFunction(getterSignature, getter),\n        getterContext: getterContext,\n        setterArgumentType: setterArgumentType,\n        setter: embind__requireFunction(setterSignature, setter),\n        setterContext: setterContext,\n      });\n    };\n\n    var __embind_register_void = (rawType, name) => {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        isVoid: true,\n        name: name,\n        argPackAdvance: 0,\n        fromWireType: () => undefined,\n        toWireType: (destructors, o) => undefined,\n      });\n    };\n\n    var __emscripten_throw_longjmp = () => {\n      throw Infinity;\n    };\n\n    var emval_methodCallers = [];\n\n    var __emval_call = (caller, handle, destructorsRef, args) => {\n      caller = emval_methodCallers[caller];\n      handle = Emval.toValue(handle);\n      return caller(null, handle, destructorsRef, args);\n    };\n\n    var emval_addMethodCaller = (caller) => {\n      var id = emval_methodCallers.length;\n      emval_methodCallers.push(caller);\n      return id;\n    };\n\n    var emval_lookupTypes = (argCount, argTypes) => {\n      var a = new Array(argCount);\n      for (var i = 0; i < argCount; ++i) {\n        a[i] = requireRegisteredType(HEAPU32[(argTypes + i * 4) >> 2], 'parameter ' + i);\n      }\n      return a;\n    };\n\n    var reflectConstruct = Reflect.construct;\n\n    var emval_returnValue = (returnType, destructorsRef, handle) => {\n      var destructors = [];\n      var result = returnType['toWireType'](destructors, handle);\n      if (destructors.length) {\n        HEAPU32[destructorsRef >> 2] = Emval.toHandle(destructors);\n      }\n      return result;\n    };\n\n    var __emval_get_method_caller = (argCount, argTypes, kind) => {\n      var types = emval_lookupTypes(argCount, argTypes);\n      var retType = types.shift();\n      argCount--;\n      var argN = new Array(argCount);\n      var invokerFunction = (obj, func, destructorsRef, args) => {\n        var offset = 0;\n        for (var i = 0; i < argCount; ++i) {\n          argN[i] = types[i]['readValueFromPointer'](args + offset);\n          offset += types[i]['argPackAdvance'];\n        }\n        var rv = kind === /* CONSTRUCTOR */ 1 ? reflectConstruct(func, argN) : func.apply(obj, argN);\n        for (var i = 0; i < argCount; ++i) {\n          types[i].deleteObject?.(argN[i]);\n        }\n        return emval_returnValue(retType, destructorsRef, rv);\n      };\n      var functionName = `methodCaller<(${types.map((t) => t.name).join(', ')}) => ${retType.name}>`;\n      return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction));\n    };\n\n    var __emval_incref = (handle) => {\n      if (handle > 4) {\n        emval_handles.get(handle).refcount += 1;\n      }\n    };\n\n    var __emval_run_destructors = (handle) => {\n      var destructors = Emval.toValue(handle);\n      runDestructors(destructors);\n      __emval_decref(handle);\n    };\n\n    var __emval_take_value = (type, arg) => {\n      type = requireRegisteredType(type, '_emval_take_value');\n      var v = type['readValueFromPointer'](arg);\n      return Emval.toHandle(v);\n    };\n\n    var _abort = () => {\n      abort('');\n    };\n\n    var _emscripten_get_now;\n\n    _emscripten_get_now = () => performance.now();\n\n    var _emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);\n\n    var getHeapMax = () => 2147483648;\n\n    var growMemory = (size) => {\n      var b = wasmMemory.buffer;\n      var pages = (size - b.byteLength + 65535) / 65536;\n      try {\n        wasmMemory.grow(pages);\n        updateMemoryViews();\n        return 1;\n      } /*success*/ catch (e) {}\n    };\n\n    var _emscripten_resize_heap = (requestedSize) => {\n      var oldSize = HEAPU8.length;\n      requestedSize >>>= 0;\n      var maxHeapSize = getHeapMax();\n      if (requestedSize > maxHeapSize) {\n        return false;\n      }\n      var alignUp = (x, multiple) => x + ((multiple - (x % multiple)) % multiple);\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n        var replacement = growMemory(newSize);\n        if (replacement) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    var ENV = {};\n\n    var getExecutableName = () => thisProgram || './this.program';\n\n    var getEnvStrings = () => {\n      if (!getEnvStrings.strings) {\n        var lang =\n          ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') +\n          '.UTF-8';\n        var env = {\n          USER: 'web_user',\n          LOGNAME: 'web_user',\n          PATH: '/',\n          PWD: '/',\n          HOME: '/home/web_user',\n          LANG: lang,\n          _: getExecutableName(),\n        };\n        for (var x in ENV) {\n          if (ENV[x] === undefined) delete env[x];\n          else env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(`${x}=${env[x]}`);\n        }\n        getEnvStrings.strings = strings;\n      }\n      return getEnvStrings.strings;\n    };\n\n    var stringToAscii = (str, buffer) => {\n      for (var i = 0; i < str.length; ++i) {\n        HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n      }\n      HEAP8[buffer >> 0] = 0;\n    };\n\n    var _environ_get = (__environ, environ_buf) => {\n      var bufSize = 0;\n      getEnvStrings().forEach((string, i) => {\n        var ptr = environ_buf + bufSize;\n        HEAPU32[(__environ + i * 4) >> 2] = ptr;\n        stringToAscii(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    };\n\n    var _environ_sizes_get = (penviron_count, penviron_buf_size) => {\n      var strings = getEnvStrings();\n      HEAPU32[penviron_count >> 2] = strings.length;\n      var bufSize = 0;\n      strings.forEach((string) => (bufSize += string.length + 1));\n      HEAPU32[penviron_buf_size >> 2] = bufSize;\n      return 0;\n    };\n\n    var _fd_close = (fd) => 52;\n\n    var _fd_read = (fd, iov, iovcnt, pnum) => 52;\n\n    var convertI32PairToI53Checked = (lo, hi) =>\n      (hi + 2097152) >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;\n\n    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n      var offset = convertI32PairToI53Checked(offset_low, offset_high);\n      return 70;\n    }\n\n    var printCharBuffers = [null, [], []];\n\n    var printChar = (stream, curr) => {\n      var buffer = printCharBuffers[stream];\n      if (curr === 0 || curr === 10) {\n        (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n        buffer.length = 0;\n      } else {\n        buffer.push(curr);\n      }\n    };\n\n    var _fd_write = (fd, iov, iovcnt, pnum) => {\n      var num = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[(iov + 4) >> 2];\n        iov += 8;\n        for (var j = 0; j < len; j++) {\n          printChar(fd, HEAPU8[ptr + j]);\n        }\n        num += len;\n      }\n      HEAPU32[pnum >> 2] = num;\n      return 0;\n    };\n\n    var initRandomFill = () => {\n      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {\n        return (view) => crypto.getRandomValues(view);\n      } else abort('initRandomDevice');\n    };\n\n    var randomFill = (view) => (randomFill = initRandomFill())(view);\n\n    var _getentropy = (buffer, size) => {\n      randomFill(HEAPU8.subarray(buffer, buffer + size));\n      return 0;\n    };\n\n    var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n\n    var arraySum = (array, index) => {\n      var sum = 0;\n      for (var i = 0; i <= index; sum += array[i++]) {}\n      return sum;\n    };\n\n    var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    var addDays = (date, days) => {\n      var newDate = new Date(date.getTime());\n      while (days > 0) {\n        var leap = isLeapYear(newDate.getFullYear());\n        var currentMonth = newDate.getMonth();\n        var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];\n        if (days > daysInCurrentMonth - newDate.getDate()) {\n          days -= daysInCurrentMonth - newDate.getDate() + 1;\n          newDate.setDate(1);\n          if (currentMonth < 11) {\n            newDate.setMonth(currentMonth + 1);\n          } else {\n            newDate.setMonth(0);\n            newDate.setFullYear(newDate.getFullYear() + 1);\n          }\n        } else {\n          newDate.setDate(newDate.getDate() + days);\n          return newDate;\n        }\n      }\n      return newDate;\n    };\n\n    /** @type {function(string, boolean=, number=)} */ function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n\n    var writeArrayToMemory = (array, buffer) => {\n      HEAP8.set(array, buffer);\n    };\n\n    var _strftime = (s, maxsize, format, tm) => {\n      var tm_zone = HEAPU32[(tm + 40) >> 2];\n      var date = {\n        tm_sec: HEAP32[tm >> 2],\n        tm_min: HEAP32[(tm + 4) >> 2],\n        tm_hour: HEAP32[(tm + 8) >> 2],\n        tm_mday: HEAP32[(tm + 12) >> 2],\n        tm_mon: HEAP32[(tm + 16) >> 2],\n        tm_year: HEAP32[(tm + 20) >> 2],\n        tm_wday: HEAP32[(tm + 24) >> 2],\n        tm_yday: HEAP32[(tm + 28) >> 2],\n        tm_isdst: HEAP32[(tm + 32) >> 2],\n        tm_gmtoff: HEAP32[(tm + 36) >> 2],\n        tm_zone: tm_zone ? UTF8ToString(tm_zone) : '',\n      };\n      var pattern = UTF8ToString(format);\n      var EXPANSION_RULES_1 = {\n        '%c': '%a %b %d %H:%M:%S %Y',\n        '%D': '%m/%d/%y',\n        '%F': '%Y-%m-%d',\n        '%h': '%b',\n        '%r': '%I:%M:%S %p',\n        '%R': '%H:%M',\n        '%T': '%H:%M:%S',\n        '%x': '%m/%d/%y',\n        '%X': '%H:%M:%S',\n        '%Ec': '%c',\n        '%EC': '%C',\n        '%Ex': '%m/%d/%y',\n        '%EX': '%H:%M:%S',\n        '%Ey': '%y',\n        '%EY': '%Y',\n        '%Od': '%d',\n        '%Oe': '%e',\n        '%OH': '%H',\n        '%OI': '%I',\n        '%Om': '%m',\n        '%OM': '%M',\n        '%OS': '%S',\n        '%Ou': '%u',\n        '%OU': '%U',\n        '%OV': '%V',\n        '%Ow': '%w',\n        '%OW': '%W',\n        '%Oy': '%y',\n      };\n      for (var rule in EXPANSION_RULES_1) {\n        pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);\n      }\n      var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n      var MONTHS = [\n        'January',\n        'February',\n        'March',\n        'April',\n        'May',\n        'June',\n        'July',\n        'August',\n        'September',\n        'October',\n        'November',\n        'December',\n      ];\n      function leadingSomething(value, digits, character) {\n        var str = typeof value == 'number' ? value.toString() : value || '';\n        while (str.length < digits) {\n          str = character[0] + str;\n        }\n        return str;\n      }\n      function leadingNulls(value, digits) {\n        return leadingSomething(value, digits, '0');\n      }\n      function compareByDay(date1, date2) {\n        function sgn(value) {\n          return value < 0 ? -1 : value > 0 ? 1 : 0;\n        }\n        var compare;\n        if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n          if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n            compare = sgn(date1.getDate() - date2.getDate());\n          }\n        }\n        return compare;\n      }\n      function getFirstWeekStartDate(janFourth) {\n        switch (janFourth.getDay()) {\n          case 0:\n            return new Date(janFourth.getFullYear() - 1, 11, 29);\n\n          case 1:\n            return janFourth;\n\n          case 2:\n            return new Date(janFourth.getFullYear(), 0, 3);\n\n          case 3:\n            return new Date(janFourth.getFullYear(), 0, 2);\n\n          case 4:\n            return new Date(janFourth.getFullYear(), 0, 1);\n\n          case 5:\n            return new Date(janFourth.getFullYear() - 1, 11, 31);\n\n          case 6:\n            return new Date(janFourth.getFullYear() - 1, 11, 30);\n        }\n      }\n      function getWeekBasedYear(date) {\n        var thisDate = addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n        var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n        var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n        var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n        var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n        if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n          if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n            return thisDate.getFullYear() + 1;\n          }\n          return thisDate.getFullYear();\n        }\n        return thisDate.getFullYear() - 1;\n      }\n      var EXPANSION_RULES_2 = {\n        '%a': (date) => WEEKDAYS[date.tm_wday].substring(0, 3),\n        '%A': (date) => WEEKDAYS[date.tm_wday],\n        '%b': (date) => MONTHS[date.tm_mon].substring(0, 3),\n        '%B': (date) => MONTHS[date.tm_mon],\n        '%C': (date) => {\n          var year = date.tm_year + 1900;\n          return leadingNulls((year / 100) | 0, 2);\n        },\n        '%d': (date) => leadingNulls(date.tm_mday, 2),\n        '%e': (date) => leadingSomething(date.tm_mday, 2, ' '),\n        '%g': (date) => getWeekBasedYear(date).toString().substring(2),\n        '%G': (date) => getWeekBasedYear(date),\n        '%H': (date) => leadingNulls(date.tm_hour, 2),\n        '%I': (date) => {\n          var twelveHour = date.tm_hour;\n          if (twelveHour == 0) twelveHour = 12;\n          else if (twelveHour > 12) twelveHour -= 12;\n          return leadingNulls(twelveHour, 2);\n        },\n        '%j': (date) =>\n          leadingNulls(\n            date.tm_mday +\n              arraySum(isLeapYear(date.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date.tm_mon - 1),\n            3,\n          ),\n        '%m': (date) => leadingNulls(date.tm_mon + 1, 2),\n        '%M': (date) => leadingNulls(date.tm_min, 2),\n        '%n': () => '\\n',\n        '%p': (date) => {\n          if (date.tm_hour >= 0 && date.tm_hour < 12) {\n            return 'AM';\n          }\n          return 'PM';\n        },\n        '%S': (date) => leadingNulls(date.tm_sec, 2),\n        '%t': () => '\\t',\n        '%u': (date) => date.tm_wday || 7,\n        '%U': (date) => {\n          var days = date.tm_yday + 7 - date.tm_wday;\n          return leadingNulls(Math.floor(days / 7), 2);\n        },\n        '%V': (date) => {\n          var val = Math.floor((date.tm_yday + 7 - ((date.tm_wday + 6) % 7)) / 7);\n          if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\n            val++;\n          }\n          if (!val) {\n            val = 52;\n            var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\n            if (dec31 == 4 || (dec31 == 5 && isLeapYear((date.tm_year % 400) - 1))) {\n              val++;\n            }\n          } else if (val == 53) {\n            var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\n            if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date.tm_year))) val = 1;\n          }\n          return leadingNulls(val, 2);\n        },\n        '%w': (date) => date.tm_wday,\n        '%W': (date) => {\n          var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);\n          return leadingNulls(Math.floor(days / 7), 2);\n        },\n        '%y': (date) => (date.tm_year + 1900).toString().substring(2),\n        '%Y': (date) => date.tm_year + 1900,\n        '%z': (date) => {\n          var off = date.tm_gmtoff;\n          var ahead = off >= 0;\n          off = Math.abs(off) / 60;\n          off = (off / 60) * 100 + (off % 60);\n          return (ahead ? '+' : '-') + String('0000' + off).slice(-4);\n        },\n        '%Z': (date) => date.tm_zone,\n        '%%': () => '%',\n      };\n      pattern = pattern.replace(/%%/g, '\\0\\0');\n      for (var rule in EXPANSION_RULES_2) {\n        if (pattern.includes(rule)) {\n          pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date));\n        }\n      }\n      pattern = pattern.replace(/\\0\\0/g, '%');\n      var bytes = intArrayFromString(pattern, false);\n      if (bytes.length > maxsize) {\n        return 0;\n      }\n      writeArrayToMemory(bytes, s);\n      return bytes.length - 1;\n    };\n\n    var _strftime_l = (s, maxsize, format, tm, loc) => _strftime(s, maxsize, format, tm);\n\n    InternalError = Module['InternalError'] = class InternalError extends Error {\n      constructor(message) {\n        super(message);\n        this.name = 'InternalError';\n      }\n    };\n\n    embind_init_charCodes();\n\n    BindingError = Module['BindingError'] = class BindingError extends Error {\n      constructor(message) {\n        super(message);\n        this.name = 'BindingError';\n      }\n    };\n\n    init_ClassHandle();\n\n    init_embind();\n\n    init_RegisteredPointer();\n\n    UnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');\n\n    handleAllocatorInit();\n\n    init_emval();\n\n    var wasmImports = {\n      /** @export */ a: ___assert_fail,\n      /** @export */ h: ___cxa_throw,\n      /** @export */ r: ___syscall_fcntl64,\n      /** @export */ I: ___syscall_getcwd,\n      /** @export */ L: ___syscall_ioctl,\n      /** @export */ M: ___syscall_openat,\n      /** @export */ Y: __embind_finalize_value_object,\n      /** @export */ D: __embind_register_bigint,\n      /** @export */ R: __embind_register_bool,\n      /** @export */ x: __embind_register_class,\n      /** @export */ v: __embind_register_class_constructor,\n      /** @export */ e: __embind_register_class_function,\n      /** @export */ Q: __embind_register_emval,\n      /** @export */ z: __embind_register_enum,\n      /** @export */ l: __embind_register_enum_value,\n      /** @export */ t: __embind_register_float,\n      /** @export */ g: __embind_register_integer,\n      /** @export */ c: __embind_register_memory_view,\n      /** @export */ X: __embind_register_smart_ptr,\n      /** @export */ u: __embind_register_std_string,\n      /** @export */ p: __embind_register_std_wstring,\n      /** @export */ y: __embind_register_value_object,\n      /** @export */ k: __embind_register_value_object_field,\n      /** @export */ S: __embind_register_void,\n      /** @export */ F: __emscripten_throw_longjmp,\n      /** @export */ W: __emval_call,\n      /** @export */ B: __emval_decref,\n      /** @export */ V: __emval_get_method_caller,\n      /** @export */ o: __emval_incref,\n      /** @export */ U: __emval_run_destructors,\n      /** @export */ n: __emval_take_value,\n      /** @export */ w: _abort,\n      /** @export */ f: _emscripten_get_now,\n      /** @export */ N: _emscripten_memcpy_js,\n      /** @export */ H: _emscripten_resize_heap,\n      /** @export */ O: _environ_get,\n      /** @export */ P: _environ_sizes_get,\n      /** @export */ s: _fd_close,\n      /** @export */ K: _fd_read,\n      /** @export */ C: _fd_seek,\n      /** @export */ J: _fd_write,\n      /** @export */ T: _getentropy,\n      /** @export */ m: invoke_ii,\n      /** @export */ d: invoke_iii,\n      /** @export */ i: invoke_iiii,\n      /** @export */ q: invoke_iiiiii,\n      /** @export */ j: invoke_vi,\n      /** @export */ b: invoke_vii,\n      /** @export */ E: invoke_viiii,\n      /** @export */ A: invoke_viiij,\n      /** @export */ G: _strftime_l,\n    };\n\n    var wasmExports = createWasm();\n\n    var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports['_'])();\n\n    var _malloc = (a0) => (_malloc = wasmExports['$'])(a0);\n\n    var _free = (a0) => (_free = wasmExports['ba'])(a0);\n\n    var ___errno_location = () => (___errno_location = wasmExports['__errno_location'])();\n\n    var ___getTypeName = (a0) => (___getTypeName = wasmExports['ca'])(a0);\n\n    var _htonl = (a0) => (_htonl = wasmExports['htonl'])(a0);\n\n    var _htons = (a0) => (_htons = wasmExports['htons'])(a0);\n\n    var _ntohs = (a0) => (_ntohs = wasmExports['ntohs'])(a0);\n\n    var _setThrew = (a0, a1) => (_setThrew = wasmExports['da'])(a0, a1);\n\n    var stackSave = () => (stackSave = wasmExports['ea'])();\n\n    var stackRestore = (a0) => (stackRestore = wasmExports['fa'])(a0);\n\n    var ___cxa_increment_exception_refcount = (a0) =>\n      (___cxa_increment_exception_refcount = wasmExports['__cxa_increment_exception_refcount'])(a0);\n\n    var ___cxa_is_pointer_type = (a0) => (___cxa_is_pointer_type = wasmExports['ga'])(a0);\n\n    var dynCall_iijj = (Module['dynCall_iijj'] = (a0, a1, a2, a3, a4, a5) =>\n      (dynCall_iijj = Module['dynCall_iijj'] = wasmExports['ha'])(a0, a1, a2, a3, a4, a5));\n\n    var dynCall_vijj = (Module['dynCall_vijj'] = (a0, a1, a2, a3, a4, a5) =>\n      (dynCall_vijj = Module['dynCall_vijj'] = wasmExports['ia'])(a0, a1, a2, a3, a4, a5));\n\n    var dynCall_jii = (Module['dynCall_jii'] = (a0, a1, a2) =>\n      (dynCall_jii = Module['dynCall_jii'] = wasmExports['ja'])(a0, a1, a2));\n\n    var dynCall_viiij = (Module['dynCall_viiij'] = (a0, a1, a2, a3, a4, a5) =>\n      (dynCall_viiij = Module['dynCall_viiij'] = wasmExports['ka'])(a0, a1, a2, a3, a4, a5));\n\n    var dynCall_jiji = (Module['dynCall_jiji'] = (a0, a1, a2, a3, a4) =>\n      (dynCall_jiji = Module['dynCall_jiji'] = wasmExports['la'])(a0, a1, a2, a3, a4));\n\n    var dynCall_viijii = (Module['dynCall_viijii'] = (a0, a1, a2, a3, a4, a5, a6) =>\n      (dynCall_viijii = Module['dynCall_viijii'] = wasmExports['ma'])(a0, a1, a2, a3, a4, a5, a6));\n\n    var dynCall_iiiiij = (Module['dynCall_iiiiij'] = (a0, a1, a2, a3, a4, a5, a6) =>\n      (dynCall_iiiiij = Module['dynCall_iiiiij'] = wasmExports['na'])(a0, a1, a2, a3, a4, a5, a6));\n\n    var dynCall_iiiiijj = (Module['dynCall_iiiiijj'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) =>\n      (dynCall_iiiiijj = Module['dynCall_iiiiijj'] = wasmExports['oa'])(a0, a1, a2, a3, a4, a5, a6, a7, a8));\n\n    var dynCall_iiiiiijj = (Module['dynCall_iiiiiijj'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) =>\n      (dynCall_iiiiiijj = Module['dynCall_iiiiiijj'] = wasmExports['pa'])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9));\n\n    function invoke_vi(index, a1) {\n      var sp = stackSave();\n      try {\n        getWasmTableEntry(index)(a1);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_vii(index, a1, a2) {\n      var sp = stackSave();\n      try {\n        getWasmTableEntry(index)(a1, a2);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_iiii(index, a1, a2, a3) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1, a2, a3);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_iii(index, a1, a2) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1, a2);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_ii(index, a1) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_iiiiii(index, a1, a2, a3, a4, a5) {\n      var sp = stackSave();\n      try {\n        return getWasmTableEntry(index)(a1, a2, a3, a4, a5);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_viiii(index, a1, a2, a3, a4) {\n      var sp = stackSave();\n      try {\n        getWasmTableEntry(index)(a1, a2, a3, a4);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_viiij(index, a1, a2, a3, a4, a5) {\n      var sp = stackSave();\n      try {\n        dynCall_viiij(index, a1, a2, a3, a4, a5);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0) throw e;\n        _setThrew(1, 0);\n      }\n    }\n\n    var calledRun;\n\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller;\n    };\n\n    function run() {\n      if (runDependencies > 0) {\n        return;\n      }\n      preRun();\n      if (runDependencies > 0) {\n        return;\n      }\n      function doRun() {\n        if (calledRun) return;\n        calledRun = true;\n        Module['calledRun'] = true;\n        if (ABORT) return;\n        initRuntime();\n        readyPromiseResolve(Module);\n        if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n        postRun();\n      }\n      if (Module['setStatus']) {\n        Module['setStatus']('Running...');\n        setTimeout(function () {\n          setTimeout(function () {\n            Module['setStatus']('');\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n\n    if (Module['preInit']) {\n      if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n      while (Module['preInit'].length > 0) {\n        Module['preInit'].pop()();\n      }\n    }\n\n    run();\n\n    return moduleArg.ready;\n  };\n})();\nexport default createDotLottiePlayerModule;\n", "/**\n * Copyright 2024 Design Barn Inc.\n */\n\nimport pkg from '../../package.json';\n\nimport createDotLottiePlayerModule from './dotlottie-player';\nimport type { MainModule } from './dotlottie-player.types';\n\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport class DotLottieWasmLoader {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  private static _ModulePromise: Promise<MainModule> | null = null;\n\n  // URL for the WASM file, constructed using package information\n  private static _wasmURL = `https://cdn.jsdelivr.net/npm/${pkg.name}@${pkg.version}/dist/dotlottie-player.wasm`;\n\n  private constructor() {\n    throw new Error('RendererLoader is a static class and cannot be instantiated.');\n  }\n\n  private static async _tryLoad(url: string): Promise<MainModule> {\n    const module = await createDotLottiePlayerModule({ locateFile: () => url });\n\n    return module;\n  }\n\n  /**\n   * Tries to load the WASM module from the primary URL, falling back to a backup URL if necessary.\n   * Throws an error if both URLs fail to load the module.\n   * @returns Promise<Module> - A promise that resolves to the loaded module.\n   */\n  private static async _loadWithBackup(): Promise<MainModule> {\n    if (!this._ModulePromise) {\n      this._ModulePromise = this._tryLoad(this._wasmURL).catch(async (initialError): Promise<MainModule> => {\n        const backupUrl = `https://unpkg.com/${pkg.name}@${pkg.version}/dist/dotlottie-player.wasm`;\n\n        console.warn(`Trying backup URL for WASM loading: ${backupUrl}`);\n        try {\n          return await this._tryLoad(backupUrl);\n        } catch (backupError) {\n          console.error(\n            `Both primary and backup WASM URLs failed. Primary error: ${\n              (initialError as Error).message\n            }, Backup error: ${(backupError as Error).message}`,\n          );\n          throw new Error('WASM loading failed from all sources.');\n        }\n      });\n    }\n\n    return this._ModulePromise;\n  }\n\n  /**\n   * Public method to load the WebAssembly module.\n   * Utilizes a primary and backup URL for robustness.\n   * @returns Promise<Module> - A promise that resolves to the loaded module.\n   */\n  public static async load(): Promise<MainModule> {\n    return this._loadWithBackup();\n  }\n\n  /**\n   * Sets a new URL for the WASM file and invalidates the current module promise.\n   *\n   * @param string -  The new URL for the WASM file.\n   */\n  public static setWasmUrl(url: string): void {\n    this._wasmURL = url;\n    // Invalidate current module promise\n    this._ModulePromise = null;\n  }\n}\n", "/**\n * Copyright 2023 Design Barn Inc.\n */\n\n/**\n * Represents the different types of events that can be dispatched.\n */\nexport type EventType =\n  | 'complete'\n  | 'frame'\n  | 'load'\n  | 'loadError'\n  | 'loop'\n  | 'pause'\n  | 'play'\n  | 'stop'\n  | 'destroy'\n  | 'freeze'\n  | 'unfreeze'\n  | 'render';\n\n/**\n * Maps an event type string to its respective event interface.\n */\ntype EventByType<T> = T extends 'complete'\n  ? CompleteEvent\n  : T extends 'frame'\n  ? FrameEvent\n  : T extends 'load'\n  ? LoadEvent\n  : T extends 'loadError'\n  ? LoadErrorEvent\n  : T extends 'loop'\n  ? LoopEvent\n  : T extends 'pause'\n  ? PauseEvent\n  : T extends 'play'\n  ? PlayEvent\n  : T extends 'stop'\n  ? StopEvent\n  : T extends 'destroy'\n  ? DestroyEvent\n  : T extends 'freeze'\n  ? FreezeEvent\n  : T extends 'unfreeze'\n  ? UnfreezeEvent\n  : T extends 'render'\n  ? RenderEvent\n  : never;\n\n/**\n * Base interface for all events.\n */\nexport interface BaseEvent {\n  type: EventType;\n}\n\nexport interface RenderEvent extends BaseEvent {\n  currentFrame: number;\n  type: 'render';\n}\n\nexport interface FreezeEvent extends BaseEvent {\n  type: 'freeze';\n}\n\nexport interface UnfreezeEvent extends BaseEvent {\n  type: 'unfreeze';\n}\n\n/*\n * Event fired when a destroy action occurs.\n */\nexport interface DestroyEvent extends BaseEvent {\n  type: 'destroy';\n}\n\n/**\n * Event fired when a loop action occurs.\n */\nexport interface LoopEvent extends BaseEvent {\n  loopCount: number;\n  type: 'loop';\n}\n\n/**\n * Event fired during frame changes.\n */\nexport interface FrameEvent extends BaseEvent {\n  currentFrame: number;\n  type: 'frame';\n}\n\n/**\n * Event fired when a load action occurs.\n */\nexport interface LoadEvent extends BaseEvent {\n  type: 'load';\n}\n\n/**\n * Event fired when a loading error occurs.\n */\nexport interface LoadErrorEvent extends BaseEvent {\n  error: Error;\n  type: 'loadError';\n}\n\n/**\n * Event fired when a completion action occurs.\n */\nexport interface CompleteEvent extends BaseEvent {\n  type: 'complete';\n}\n\n/**\n * Event fired when a pause action occurs.\n */\nexport interface PauseEvent extends BaseEvent {\n  type: 'pause';\n}\n\n/**\n * Event fired when a play action occurs.\n */\nexport interface PlayEvent extends BaseEvent {\n  type: 'play';\n}\n\n/**\n * Event fired when a stop action occurs.\n */\nexport interface StopEvent extends BaseEvent {\n  type: 'stop';\n}\n\n/**\n * Represents all possible event types.\n */\nexport type Event =\n  | LoopEvent\n  | FrameEvent\n  | LoadEvent\n  | LoadErrorEvent\n  | CompleteEvent\n  | PauseEvent\n  | PlayEvent\n  | StopEvent;\n\n/**\n * Type for event listener callbacks.\n */\nexport interface EventListener<T extends EventType> {\n  (event: EventByType<T>): void;\n}\n\n/**\n * Manages registration and dispatching of event listeners.\n */\nexport class EventManager {\n  private readonly _eventListeners: Map<EventType, Set<EventListener<EventType>>> = new Map();\n\n  public addEventListener<T extends EventType>(type: T, listener: EventListener<T>): void {\n    let listeners = this._eventListeners.get(type);\n\n    if (!listeners) {\n      listeners = new Set<EventListener<T>>();\n      this._eventListeners.set(type, listeners);\n    }\n\n    listeners.add(listener);\n  }\n\n  public removeEventListener<T extends EventType>(type: T, listener?: EventListener<T>): void {\n    const listeners = this._eventListeners.get(type);\n\n    if (!listeners) return;\n\n    if (listener) {\n      listeners.delete(listener);\n\n      if (listeners.size === 0) {\n        this._eventListeners.delete(type);\n      }\n    } else {\n      this._eventListeners.delete(type);\n    }\n  }\n\n  public dispatch<T extends EventType>(event: EventByType<T>): void {\n    const listeners = this._eventListeners.get(event.type);\n\n    listeners?.forEach((listener) => listener(event));\n  }\n\n  public removeAllEventListeners(): void {\n    this._eventListeners.clear();\n  }\n}\n", "/**\n * Copyright 2024 Design Barn Inc.\n */\n\nimport { AnimationFrameManager } from './animation-frame-manager';\nimport { IS_BROWSER } from './constants';\nimport type { DotLottiePlayer, MainModule, Mode as CoreMode, VectorFloat } from './core';\nimport { DotLottieWasmLoader } from './core';\nimport type { EventListener, EventType } from './event-manager';\nimport { EventManager } from './event-manager';\n\nexport interface RenderConfig {\n  devicePixelRatio?: number;\n}\n\nexport type Mode = 'forward' | 'reverse' | 'bounce' | 'reverse-bounce';\n\nexport type Data = string | ArrayBuffer | Record<string, unknown>;\n\nexport interface Config {\n  autoplay?: boolean;\n  backgroundColor?: string;\n  canvas: HTMLCanvasElement;\n  data?: Data;\n  loop?: boolean;\n  mode?: Mode;\n  renderConfig?: RenderConfig;\n  segments?: [number, number];\n  speed?: number;\n  src?: string;\n  useFrameInterpolation?: boolean;\n}\n\nexport interface Manifest {\n  activeAnimationId?: string;\n  animations: Array<{\n    autoplay?: boolean;\n    defaultTheme?: string;\n    direction?: 1 | -1;\n    hover?: boolean;\n    id: string;\n    intermission?: number;\n    loop?: boolean | number;\n    playMode?: 'bounce' | 'normal';\n    speed?: number;\n    themeColor?: string;\n  }>;\n  author?: string;\n  custom?: Record<string, unknown>;\n  description?: string;\n  generator?: string;\n  keywords?: string;\n  revision?: number;\n  states?: string[];\n  themes?: Array<{ animations: string[]; id: string }>;\n  version?: string;\n}\n\nconst createCoreMode = (mode: Mode, module: MainModule): CoreMode => {\n  if (mode === 'reverse') {\n    return module.Mode.Reverse;\n  } else if (mode === 'bounce') {\n    return module.Mode.Bounce;\n  } else if (mode === 'reverse-bounce') {\n    return module.Mode.ReverseBounce;\n  } else {\n    return module.Mode.Forward;\n  }\n};\n\nconst createCoreSegments = (segments: number[], module: MainModule): VectorFloat => {\n  const coreSegments = new module.VectorFloat();\n\n  if (segments.length !== 2) return coreSegments;\n\n  coreSegments.push_back(segments[0] as number);\n  coreSegments.push_back(segments[1] as number);\n\n  return coreSegments;\n};\n\nexport class DotLottie {\n  private readonly _canvas: HTMLCanvasElement | OffscreenCanvas;\n\n  private _context: CanvasRenderingContext2D | null;\n\n  private readonly _eventManager: EventManager;\n\n  private _animationFrameId: number | null = null;\n\n  private readonly _frameManager: AnimationFrameManager;\n\n  private _dotLottieCore: DotLottiePlayer | null = null;\n\n  private _wasmModule: MainModule | null = null;\n\n  private _renderConfig: RenderConfig = {};\n\n  private _isFrozen: boolean = false;\n\n  private _backgroundColor: string | null = null;\n\n  public constructor(config: Config) {\n    this._canvas = config.canvas;\n    this._context = this._canvas.getContext('2d');\n    this._eventManager = new EventManager();\n    this._frameManager = new AnimationFrameManager();\n    this._renderConfig = config.renderConfig ?? {};\n\n    DotLottieWasmLoader.load()\n      .then((module) => {\n        this._wasmModule = module;\n\n        this._dotLottieCore = new module.DotLottiePlayer({\n          autoplay: config.autoplay ?? false,\n          backgroundColor: 0,\n          loopAnimation: config.loop ?? false,\n          mode: createCoreMode(config.mode ?? 'forward', module),\n          segments: createCoreSegments(config.segments ?? [], module),\n          speed: config.speed ?? 1,\n          useFrameInterpolation: config.useFrameInterpolation ?? true,\n        });\n\n        if (config.data) {\n          this._loadFromData(config.data);\n        } else if (config.src) {\n          this._loadFromSrc(config.src);\n        }\n\n        if (config.backgroundColor) {\n          this.setBackgroundColor(config.backgroundColor);\n        }\n      })\n      .catch((error) => {\n        this._eventManager.dispatch({\n          type: 'loadError',\n          error: new Error(`Failed to load wasm module: ${error}`),\n        });\n      });\n  }\n\n  private _loadFromSrc(src: string): void {\n    async function load(): Promise<string | ArrayBuffer> {\n      const response = await fetch(src);\n\n      if (!response.ok) {\n        throw new Error(\n          `Failed to fetch the animation data from URL: ${src}. ${response.status}: ${response.statusText}`,\n        );\n      }\n\n      const contentType = response.headers.get('content-type');\n\n      let data: string | ArrayBuffer;\n\n      if (['application/json', 'text/plain'].includes(contentType ?? '')) {\n        data = await response.text();\n      } else {\n        data = await response.arrayBuffer();\n      }\n\n      return data;\n    }\n\n    load()\n      .then((data) => {\n        this._loadFromData(data);\n      })\n      .catch((error) => {\n        this._eventManager.dispatch({\n          type: 'loadError',\n          error: new Error(`Failed to load animation data from URL: ${src}. ${error}`),\n        });\n      });\n  }\n\n  private _loadFromData(data: Data): void {\n    if (this._dotLottieCore === null) return;\n\n    const width = this._canvas.width;\n    const height = this._canvas.height;\n\n    let loaded = false;\n\n    if (typeof data === 'string') {\n      loaded = this._dotLottieCore.loadAnimationData(data, width, height);\n    } else if (data instanceof ArrayBuffer) {\n      loaded = this._dotLottieCore.loadDotLottieData(data, width, height);\n    } else if (typeof data === 'object') {\n      loaded = this._dotLottieCore.loadAnimationData(JSON.stringify(data), width, height);\n    } else {\n      this._eventManager.dispatch({\n        type: 'loadError',\n        error: new Error('Unsupported data type for animation data. Expected a string or ArrayBuffer.'),\n      });\n\n      return;\n    }\n\n    if (loaded) {\n      this._eventManager.dispatch({ type: 'load' });\n\n      if (IS_BROWSER) {\n        this.resize();\n      }\n\n      this._eventManager.dispatch({\n        type: 'frame',\n        currentFrame: this._dotLottieCore.currentFrame(),\n      });\n\n      this._render();\n\n      if (this._dotLottieCore.config().autoplay) {\n        this._dotLottieCore.play();\n        if (this._dotLottieCore.isPlaying()) {\n          this._eventManager.dispatch({ type: 'play' });\n          this._animationFrameId = this._frameManager.requestAnimationFrame(this._draw.bind(this));\n        } else {\n          console.error('something went wrong, the animation was suppose to autoplay');\n        }\n      }\n    } else {\n      this._eventManager.dispatch({\n        type: 'loadError',\n        error: new Error('Failed to load animation data'),\n      });\n    }\n  }\n\n  public get manifest(): Manifest | null {\n    try {\n      const manifest = this._dotLottieCore?.manifestString();\n\n      if (this._dotLottieCore === null || !manifest) return null;\n\n      const manifestJson = JSON.parse(manifest);\n\n      if (Object.keys(manifestJson).length === 0) return null;\n\n      return manifestJson as Manifest;\n    } catch (_err) {\n      return null;\n    }\n  }\n\n  public get renderConfig(): RenderConfig {\n    return this._renderConfig;\n  }\n\n  public get segments(): [number, number] | undefined {\n    const segments = this._dotLottieCore?.config().segments;\n\n    if (segments && segments.size() === 2) {\n      return [segments.get(0) as number, segments.get(1) as number];\n    }\n\n    return undefined;\n  }\n\n  public get loop(): boolean {\n    return this._dotLottieCore?.config().loopAnimation ?? false;\n  }\n\n  public get mode(): Mode {\n    const mode = this._dotLottieCore?.config().mode;\n\n    if (mode === this._wasmModule?.Mode.Reverse) {\n      return 'reverse';\n    } else if (mode === this._wasmModule?.Mode.Bounce) {\n      return 'bounce';\n    } else if (mode === this._wasmModule?.Mode.ReverseBounce) {\n      return 'reverse-bounce';\n    } else {\n      return 'forward';\n    }\n  }\n\n  public get isFrozen(): boolean {\n    return this._isFrozen;\n  }\n\n  public get backgroundColor(): string {\n    return this._backgroundColor ?? '';\n  }\n\n  public get autoplay(): boolean {\n    return this._dotLottieCore?.config().autoplay ?? false;\n  }\n\n  public get useFrameInterpolation(): boolean {\n    return this._dotLottieCore?.config().useFrameInterpolation ?? false;\n  }\n\n  public get speed(): number {\n    return this._dotLottieCore?.config().speed ?? 0;\n  }\n\n  public get isLoaded(): boolean {\n    return this._dotLottieCore?.isLoaded() ?? false;\n  }\n\n  public get isPlaying(): boolean {\n    return this._dotLottieCore?.isPlaying() ?? false;\n  }\n\n  public get isPaused(): boolean {\n    return this._dotLottieCore?.isPaused() ?? false;\n  }\n\n  public get isStopped(): boolean {\n    return this._dotLottieCore?.isStopped() ?? false;\n  }\n\n  public get currentFrame(): number {\n    return this._dotLottieCore?.currentFrame() ?? 0;\n  }\n\n  public get loopCount(): number {\n    return this._dotLottieCore?.loopCount() ?? 0;\n  }\n\n  public get totalFrames(): number {\n    return this._dotLottieCore?.totalFrames() ?? 0;\n  }\n\n  public get duration(): number {\n    return this._dotLottieCore?.duration() ?? 0;\n  }\n\n  public load(config: Omit<Config, 'canvas'>): void {\n    if (this._dotLottieCore === null || this._wasmModule === null) return;\n\n    this._dotLottieCore.setConfig({\n      autoplay: config.autoplay ?? false,\n      backgroundColor: 0,\n      loopAnimation: config.loop ?? false,\n      mode: createCoreMode(config.mode ?? 'forward', this._wasmModule),\n      segments: createCoreSegments(config.segments ?? [], this._wasmModule),\n      speed: config.speed ?? 1,\n      useFrameInterpolation: config.useFrameInterpolation ?? true,\n    });\n\n    if (config.data) {\n      this._loadFromData(config.data);\n    } else if (config.src) {\n      this._loadFromSrc(config.src);\n    }\n\n    this.setBackgroundColor(config.backgroundColor ?? '');\n  }\n\n  private _render(): boolean {\n    if (this._dotLottieCore === null || this._context === null) return false;\n\n    const rendered = this._dotLottieCore.render();\n\n    if (rendered) {\n      const buffer = this._dotLottieCore.buffer() as Uint8ClampedArray;\n\n      const imageData = this._context.createImageData(this._canvas.width, this._canvas.height);\n\n      imageData.data.set(buffer);\n\n      this._context.putImageData(imageData, 0, 0);\n\n      this._eventManager.dispatch({\n        type: 'render',\n        currentFrame: this._dotLottieCore.currentFrame(),\n      });\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private _draw(): void {\n    if (this._dotLottieCore === null || this._context === null || !this._dotLottieCore.isPlaying()) return;\n\n    const nextFrame = this._dotLottieCore.requestFrame();\n\n    const updated = this._dotLottieCore.setFrame(nextFrame);\n\n    if (updated) {\n      this._eventManager.dispatch({\n        type: 'frame',\n        currentFrame: this._dotLottieCore.currentFrame(),\n      });\n\n      const rendered = this._render();\n\n      if (rendered) {\n        // handle loop or complete\n        if (this._dotLottieCore.isComplete()) {\n          if (this._dotLottieCore.config().loopAnimation) {\n            this._eventManager.dispatch({\n              type: 'loop',\n              loopCount: this._dotLottieCore.loopCount(),\n            });\n          } else {\n            this._eventManager.dispatch({ type: 'complete' });\n          }\n        }\n      }\n    }\n\n    this._animationFrameId = this._frameManager.requestAnimationFrame(this._draw.bind(this));\n  }\n\n  public play(): void {\n    if (this._dotLottieCore === null) return;\n\n    const ok = this._dotLottieCore.play();\n\n    this._isFrozen = false;\n\n    if (ok) {\n      this._eventManager.dispatch({ type: 'play' });\n      this._animationFrameId = this._frameManager.requestAnimationFrame(this._draw.bind(this));\n    }\n  }\n\n  public pause(): void {\n    if (this._dotLottieCore === null) return;\n\n    const ok = this._dotLottieCore.pause();\n\n    if (ok) {\n      this._eventManager.dispatch({ type: 'pause' });\n    }\n  }\n\n  public stop(): void {\n    if (this._dotLottieCore === null) return;\n\n    const ok = this._dotLottieCore.stop();\n\n    if (ok) {\n      this._eventManager.dispatch({ type: 'frame', currentFrame: this._dotLottieCore.currentFrame() });\n\n      this._render();\n\n      this._eventManager.dispatch({ type: 'stop' });\n    }\n  }\n\n  public setFrame(frame: number): void {\n    if (this._dotLottieCore === null) return;\n\n    if (frame < 0 || frame > this._dotLottieCore.totalFrames()) return;\n\n    const ok = this._dotLottieCore.seek(frame);\n\n    if (ok) {\n      this._eventManager.dispatch({ type: 'frame', currentFrame: this._dotLottieCore.currentFrame() });\n\n      this._render();\n    }\n  }\n\n  public setSpeed(speed: number): void {\n    if (this._dotLottieCore === null) return;\n\n    this._dotLottieCore.setConfig({\n      ...this._dotLottieCore.config(),\n      speed,\n    });\n  }\n\n  public setBackgroundColor(color: string): void {\n    if (this._dotLottieCore === null) return;\n\n    if (this._canvas instanceof HTMLCanvasElement) {\n      this._canvas.style.backgroundColor = color;\n    }\n\n    this._backgroundColor = color;\n  }\n\n  public setLoop(loop: boolean): void {\n    if (this._dotLottieCore === null) return;\n\n    this._dotLottieCore.setConfig({\n      ...this._dotLottieCore.config(),\n      loopAnimation: loop,\n    });\n  }\n\n  public setUseFrameInterpolation(useFrameInterpolation: boolean): void {\n    if (this._dotLottieCore === null) return;\n\n    this._dotLottieCore.setConfig({\n      ...this._dotLottieCore.config(),\n      useFrameInterpolation,\n    });\n  }\n\n  public addEventListener<T extends EventType>(type: T, listener: EventListener<T>): void {\n    this._eventManager.addEventListener(type, listener);\n  }\n\n  public removeEventListener<T extends EventType>(type: T, listener?: EventListener<T>): void {\n    this._eventManager.removeEventListener(type, listener);\n  }\n\n  public destroy(): void {\n    this._dotLottieCore?.delete();\n    this._dotLottieCore = null;\n    this._context = null;\n\n    this._eventManager.dispatch({\n      type: 'destroy',\n    });\n\n    this._eventManager.removeAllEventListeners();\n  }\n\n  public freeze(): void {\n    if (this._animationFrameId === null) return;\n\n    this._frameManager.cancelAnimationFrame(this._animationFrameId);\n    this._animationFrameId = null;\n\n    this._isFrozen = true;\n\n    this._eventManager.dispatch({ type: 'freeze' });\n  }\n\n  public unfreeze(): void {\n    if (this._animationFrameId !== null) return;\n\n    this._animationFrameId = this._frameManager.requestAnimationFrame(this._draw.bind(this));\n\n    this._isFrozen = false;\n\n    this._eventManager.dispatch({ type: 'unfreeze' });\n  }\n\n  public resize(): void {\n    if (!IS_BROWSER || !(this._canvas instanceof HTMLCanvasElement)) return;\n\n    const dpr = this._renderConfig.devicePixelRatio || window.devicePixelRatio || 1;\n\n    const { height: clientHeight, width: clientWidth } = this._canvas.getBoundingClientRect();\n\n    this._canvas.width = clientWidth * dpr;\n    this._canvas.height = clientHeight * dpr;\n\n    const ok = this._dotLottieCore?.resize(this._canvas.width, this._canvas.height);\n\n    if (ok) {\n      this._render();\n    }\n  }\n\n  public setSegments(startFrame: number, endFrame: number): void {\n    if (this._dotLottieCore === null || this._wasmModule === null) return;\n\n    this._dotLottieCore.setConfig({\n      ...this._dotLottieCore.config(),\n      segments: createCoreSegments([startFrame, endFrame], this._wasmModule),\n    });\n  }\n\n  public setMode(mode: Mode): void {\n    if (this._dotLottieCore === null || this._wasmModule === null) return;\n\n    this._dotLottieCore.setConfig({\n      ...this._dotLottieCore.config(),\n      mode: createCoreMode(mode, this._wasmModule),\n    });\n  }\n\n  public setRenderConfig(config: RenderConfig): void {\n    this._renderConfig = config;\n  }\n\n  public loadAnimation(animationId: string): void {\n    if (this._dotLottieCore === null) return;\n\n    const loaded = this._dotLottieCore.loadAnimation(animationId, this._canvas.width, this._canvas.height);\n\n    if (loaded) {\n      this._eventManager.dispatch({ type: 'load' });\n      this.resize();\n    } else {\n      this._eventManager.dispatch({\n        type: 'loadError',\n        error: new Error(`Failed to animation :${animationId}`),\n      });\n    }\n  }\n\n  public static setWasmUrl(url: string): void {\n    DotLottieWasmLoader.setWasmUrl(url);\n  }\n}\n", "import { DotLottie } from '@lottiefiles/dotlottie-web';\nimport { defineComponent, ref, toRefs, watch, onMounted, onBeforeUnmount, h } from 'vue';\n\n// src/dotlottie.ts\nvar DotLottieVue = defineComponent({\n  props: {\n    autoplay: { type: Boolean, required: false },\n    backgroundColor: { type: String, required: false },\n    data: { type: [String, ArrayBuffer], required: false },\n    loop: { type: Boolean, required: false },\n    mode: { type: String, required: false },\n    renderConfig: { type: Object, required: false },\n    segments: { type: Array, required: false },\n    speed: { type: Number, required: false },\n    src: { type: String, required: false },\n    useFrameInterpolation: { type: Boolean, required: false }\n  },\n  setup(props, { attrs, expose }) {\n    const canvas = ref(void 0);\n    const { backgroundColor, loop, mode, segments, speed, useFrameInterpolation } = toRefs(props);\n    let dotLottie = null;\n    let intersectionObserver = null;\n    let resizeObserver = null;\n    watch(\n      () => backgroundColor?.value,\n      (newVal) => {\n        if (dotLottie && typeof newVal !== \"undefined\") {\n          dotLottie.setBackgroundColor(newVal);\n        }\n      }\n    );\n    watch(\n      () => loop?.value,\n      (newVal) => {\n        if (dotLottie && typeof newVal !== \"undefined\") {\n          dotLottie.setLoop(newVal);\n        }\n      }\n    );\n    watch(\n      () => mode?.value,\n      (newVal) => {\n        if (dotLottie && typeof newVal !== \"undefined\") {\n          dotLottie.setMode(newVal);\n        }\n      }\n    );\n    watch(\n      () => segments?.value,\n      (newVal) => {\n        if (dotLottie && Array.isArray(newVal) && newVal.length === 2) {\n          dotLottie.setSegments(newVal[0], newVal[1]);\n        }\n      }\n    );\n    watch(\n      () => speed?.value,\n      (newVal) => {\n        if (dotLottie && typeof newVal !== \"undefined\") {\n          dotLottie.setSpeed(newVal);\n        }\n      }\n    );\n    watch(\n      () => useFrameInterpolation?.value,\n      (newVal) => {\n        if (dotLottie && typeof newVal !== \"undefined\") {\n          dotLottie.setUseFrameInterpolation(newVal);\n        }\n      }\n    );\n    function getIntersectionObserver() {\n      return new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n              dotLottie?.unfreeze();\n            } else {\n              dotLottie?.freeze();\n            }\n          });\n        },\n        {\n          threshold: 0\n        }\n      );\n    }\n    function getResizeObserver() {\n      return new ResizeObserver((entries) => {\n        entries.forEach(() => {\n          dotLottie?.resize();\n        });\n      });\n    }\n    function onVisibilityChange() {\n      if (document.hidden) {\n        dotLottie?.freeze();\n      } else {\n        dotLottie?.unfreeze();\n      }\n    }\n    onMounted(() => {\n      if (!canvas.value)\n        return;\n      dotLottie = new DotLottie({\n        canvas: canvas.value,\n        ...props\n      });\n      intersectionObserver = getIntersectionObserver();\n      resizeObserver = getResizeObserver();\n      intersectionObserver.observe(canvas.value);\n      resizeObserver.observe(canvas.value);\n      document.addEventListener(\"visibilitychange\", onVisibilityChange);\n    });\n    onBeforeUnmount(() => {\n      resizeObserver?.disconnect();\n      intersectionObserver?.disconnect();\n      document.removeEventListener(\"visibilitychange\", onVisibilityChange);\n      dotLottie?.destroy();\n    });\n    expose({\n      getDotLottieInstance: () => dotLottie\n    });\n    return () => h(\"div\", { ...attrs }, h(\"canvas\", { style: \"height: 100%; width: 100%\", ref: canvas }));\n  }\n});\n\nexport { DotLottieVue };\n"],
  "mappings": "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",
  "names": ["WebAnimationFrameStrategy", "callback", "id", "NodeAnimationFrameStrategy", "__publicField", "AnimationFrameManager", "IS_BROWSER", "package_default", "createDotLottiePlayerModule", "_scriptDir", "Module", "moduleArg", "readyPromiseReject", "reject", "readyPromiseResolve", "moduleOverrides", "arguments_", "thisProgram", "quit_", "status", "toThrow", "ENVIRONMENT_IS_WEB", "ENVIRONMENT_IS_WORKER", "locateFile", "path", "scriptDirectory", "read_", "xhr", "url", "readBinary", "readAsync", "onload", "out", "err", "wasmMemory", "ABORT", "EXITSTATUS", "HEAP8", "HEAPU8", "HEAP16", "HEAPU16", "HEAP32", "HEAPU32", "HEAPF32", "updateMemoryViews", "b", "HEAPF64", "__ATINIT__", "__ATPOSTRUN__", "addOnPreRun", "runtimeInitialized", "callRuntimeCallbacks", "addOnInit", "cb", "runDependencyWatcher", "runDependencies", "dependenciesFulfilled", "what", "dataURIPrefix", "wasmBinaryFile", "isDataURI", "getBinarySync", "file", "getBinaryPromise", "binaryFile", "wasmBinary", "response", "imports", "receiver", "reason", "abort", "binary", "createWasm", "receiveInstance", "wasmExports", "wasmTable", "removeRunDependency", "addRunDependency", "receiveInstantiationResult", "result", "info", "callbacks", "noExitRuntime", "UTF8Decoder", "UTF8ArrayToString", "idx", "maxBytesToRead", "heapOrArray", "endPtr", "endIdx", "u1", "u0", "str", "u2", "ch", "ptr", "___assert_fail", "condition", "filename", "line", "func", "UTF8ToString", "ExceptionInfo", "excPtr", "type", "caught", "isPointer", "___cxa_is_pointer_type", "adjusted", "exceptionLast", "uncaughtExceptionCount", "___cxa_throw", "destructor", "SYSCALLS", "ret", "___syscall_fcntl64", "fd", "cmd", "varargs", "lengthBytesUTF8", "len", "i", "c", "stringToUTF8Array", "heap", "outIdx", "maxBytesToWrite", "u", "startIdx", "stringToUTF8", "outPtr", "___syscall_getcwd", "buf", "size", "___syscall_ioctl", "op", "___syscall_openat", "dirfd", "structRegistrations", "destructors", "awaitingDependencies", "registeredTypes", "typeDependencies", "InternalError", "throwInternalError", "message", "whenDependentTypesAreResolved", "dependentTypes", "getTypeConverters", "myTypes", "h", "myTypeConverters", "registerType", "typeConverters", "unregisteredTypes", "registered", "dt", "reg", "rawConstructor", "fieldRecords", "fieldTypes", "structType", "fields", "fieldName", "field", "getterReturnType", "getter", "setterArgumentType", "setterContext", "getterContext", "o", "setter", "simpleReadValueFromPointer", "codes", "embind_charCodes", "readLatin1String", "BindingError", "rawType", "registeredInstance", "throwBindingError", "options", "sharedRegisterType", "GenericWireTypeSize", "falseValue", "name", "wt", "throwInstanceAlreadyDeleted", "obj", "getInstanceTypeName", "handle", "detachFinalizer", "$$", "releaseClassHandle", "toDelete", "downcastPointer", "ptrClass", "rv", "desiredClass", "getLiveInheritedInstances", "registeredInstances", "deletionQueue", "delayFunction", "setDelayFunction", "fn", "flushPendingDeletes", "getInheritedInstanceCount", "getBasestPointer", "class_", "record", "hasSmartPtrType", "hasSmartPtr", "attachFinalizer", "rawPointer", "getInheritedInstance", "makeClassHandle", "registeredPointerRecord", "actualType", "toType", "dp", "finalizationRegistry", "ClassHandle", "other", "left", "leftClass", "right", "rightClass", "shallowCopyInternalPointer", "clone", "body", "ensureOverloadTable", "methodName", "humanName", "proto", "value", "numArguments", "char_9", "upcast", "instancePrototype", "getActualType", "constNoSmartPtrRawPointerToWireType", "upcastPointer", "genericPointerToWireType", "handleClass", "clonedHandle", "Emval", "nonConstNoSmartPtrRawPointerToWireType", "embindRepr", "readPointer", "pointer", "init_RegisteredPointer", "RegisteredPointer", "registeredClass", "isReference", "isConst", "rawGetPointee", "rawShare", "rawDestructor", "sharingPolicy", "isSmartPointer", "replacePublicSymbol", "dynCallLegacy", "args", "f", "stack", "errorClass", "baseErrorType", "UnboundTypeError", "getTypeName", "___getTypeName", "_free", "throwUnboundTypeError", "types", "unboundTypes", "seen", "visit", "__embind_register_class", "rawPointerType", "rawConstPointerType", "baseClassRawType", "getActualTypeSignature", "upcastSignature", "downcastSignature", "downcast", "destructorSignature", "embind__requireFunction", "makeLegalFunctionName", "exposePublicSymbol", "base", "basePrototype", "baseClass", "createNamedFunction", "constructor", "pointerConverter", "constPointerConverter", "legalFunctionName", "referenceConverter", "heap32VectorToArray", "count", "firstElement", "array", "argTypes", "cppInvokerFunc", "cppTargetFunc", "isAsync", "argCount", "isClassMethodFunc", "classType", "needsDestructorStack", "returns", "argsWired", "expectedArgCount", "invokerFn", "thisWired", "invokerFuncArgs", "runDestructors", "param", "onDone", "__embind_register_class_constructor", "invokerSignature", "invoker", "rawArgTypesAddr", "rawArgTypes", "getFunctionName", "signature", "argsIndex", "__embind_register_class_function", "rawClassType", "rawInvoker", "context", "isPureVirtual", "unboundTypesHandler", "method", "craftInvokerFunction", "memberFunction", "handleAllocatorInit", "HandleAllocator", "emval_handles", "count_emval_handles", "init_emval", "__embind_register_emval", "width", "signed", "__embind_register_enum", "isSigned", "ctor", "impl", "enumValue", "requireRegisteredType", "rawEnumType", "enumType", "Value", "Enum", "v", "floatReadValueFromPointer", "primitiveType", "maxRange", "fromWireType", "minRange", "bitshift", "isUnsignedType", "checkAssertions", "toTypeName", "toWireType", "integerReadValueFromPointer", "__embind_register_memory_view", "dataTypeIndex", "typeMapping", "TA", "decodeMemoryView", "data", "__embind_register_smart_ptr", "rawPointeeType", "getPointeeSignature", "constructorSignature", "shareSignature", "pointeeType", "registeredPointer", "__embind_register_std_string", "stdStringIsUTF8", "length", "payload", "decodeStartPtr", "currentBytePtr", "maxRead", "stringSegment", "a", "valueIsOfTypeString", "_malloc", "charCode", "UTF16Decoder", "UTF16ToString", "maxIdx", "codeUnit", "startPtr", "lengthBytesUTF16", "UTF32ToString", "utf32", "stringToUTF32", "trailSurrogate", "lengthBytesUTF32", "__embind_register_std_wstring", "decodeString", "encodeString", "getHeap", "lengthBytesUTF", "shift", "charSize", "HEAP", "__embind_register_value_object", "__embind_register_value_object_field", "getterSignature", "emval_methodCallers", "__emval_call", "destructorsRef", "caller", "emval_addMethodCaller", "emval_returnValue", "returnType", "__emval_get_method_caller", "emval_lookupTypes", "retType", "argN", "invokerFunction", "offset", "functionName", "__emval_run_destructors", "__emval_decref", "arg", "_emscripten_get_now", "_emscripten_memcpy_js", "dest", "src", "getHeapMax", "growMemory", "pages", "requestedSize", "oldSize", "maxHeapSize", "alignUp", "x", "multiple", "cutDown", "overGrownHeapSize", "newSize", "replacement", "ENV", "getEnvStrings", "lang", "env", "strings", "buffer", "_environ_get", "bufSize", "environ_buf", "stringToAscii", "string", "_environ_sizes_get", "penviron_count", "penviron_buf_size", "_fd_close", "iov", "iovcnt", "pnum", "convertI32PairToI53Checked", "lo", "hi", "offset_low", "offset_high", "whence", "newOffset", "printChar", "stream", "curr", "_fd_write", "num", "j", "view", "randomFill", "initRandomFill", "_getentropy", "isLeapYear", "year", "index", "sum", "MONTH_DAYS_LEAP", "MONTH_DAYS_REGULAR", "addDays", "date", "days", "leap", "newDate", "daysInCurrentMonth", "intArrayFromString", "stringy", "dontAddNull", "numBytesWritten", "u8array", "writeArrayToMemory", "_strftime", "s", "maxsize", "tm", "pattern", "rule", "EXPANSION_RULES_1", "WEEKDAYS", "character", "digits", "compareByDay", "date2", "sgn", "compare", "date1", "getFirstWeekStartDate", "janFourth", "getWeekBasedYear", "thisDate", "janFourthThisYear", "firstWeekStartThisYear", "firstWeekStartNextYear", "MONTHS", "leadingNulls", "leadingSomething", "twelveHour", "arraySum", "val", "jan1", "dec31", "off", "EXPANSION_RULES_2", "bytes", "_strftime_l", "format", "loc", "embind_init_charCodes", "init_ClassHandle", "init_embind", "wasmImports", "__embind_finalize_value_object", "__embind_register_bigint", "__embind_register_bool", "__embind_register_enum_value", "__embind_register_float", "__embind_register_integer", "__embind_register_void", "__emscripten_throw_longjmp", "__emval_incref", "__emval_take_value", "_abort", "_emscripten_resize_heap", "_fd_read", "_fd_seek", "invoke_ii", "invoke_iii", "invoke_iiii", "invoke_iiiiii", "invoke_vi", "invoke_vii", "invoke_viiii", "invoke_viiij", "___wasm_call_ctors", "a0", "___errno_location", "_htonl", "_htons", "_ntohs", "_setThrew", "a1", "stackSave", "stackRestore", "a3", "a4", "a2", "a5", "dynCall_jiji", "a6", "dynCall_viijii", "dynCall_iiiiij", "dynCall_iiiiijj", "a8", "a7", "dynCall_iiiiiijj", "a9", "sp", "getWasmTableEntry", "e", "dynCall_viiij", "calledRun", "run", "runCaller", "postRun", "EventManager", "listener", "listeners", "event", "module", "mode", "createCoreSegments", "segments", "coreSegments", "config", "DotLottieWasmLoader", "createCoreMode", "error", "contentType", "loaded", "manifest", "frame", "dpr", "clientWidth", "startFrame", "endFrame", "animationId"]
}
