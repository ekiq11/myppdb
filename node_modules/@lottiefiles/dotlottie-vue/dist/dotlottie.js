import { DotLottie } from '@lottiefiles/dotlottie-web';
import { defineComponent, ref, toRefs, watch, onMounted, onBeforeUnmount, h } from 'vue';

// src/dotlottie.ts
var DotLottieVue = defineComponent({
  props: {
    autoplay: { type: Boolean, required: false },
    backgroundColor: { type: String, required: false },
    data: { type: [String, ArrayBuffer], required: false },
    loop: { type: Boolean, required: false },
    mode: { type: String, required: false },
    renderConfig: { type: Object, required: false },
    segments: { type: Array, required: false },
    speed: { type: Number, required: false },
    src: { type: String, required: false },
    useFrameInterpolation: { type: Boolean, required: false }
  },
  setup(props, { attrs, expose }) {
    const canvas = ref(void 0);
    const { backgroundColor, loop, mode, segments, speed, useFrameInterpolation } = toRefs(props);
    let dotLottie = null;
    let intersectionObserver = null;
    let resizeObserver = null;
    watch(
      () => backgroundColor?.value,
      (newVal) => {
        if (dotLottie && typeof newVal !== "undefined") {
          dotLottie.setBackgroundColor(newVal);
        }
      }
    );
    watch(
      () => loop?.value,
      (newVal) => {
        if (dotLottie && typeof newVal !== "undefined") {
          dotLottie.setLoop(newVal);
        }
      }
    );
    watch(
      () => mode?.value,
      (newVal) => {
        if (dotLottie && typeof newVal !== "undefined") {
          dotLottie.setMode(newVal);
        }
      }
    );
    watch(
      () => segments?.value,
      (newVal) => {
        if (dotLottie && Array.isArray(newVal) && newVal.length === 2) {
          dotLottie.setSegments(newVal[0], newVal[1]);
        }
      }
    );
    watch(
      () => speed?.value,
      (newVal) => {
        if (dotLottie && typeof newVal !== "undefined") {
          dotLottie.setSpeed(newVal);
        }
      }
    );
    watch(
      () => useFrameInterpolation?.value,
      (newVal) => {
        if (dotLottie && typeof newVal !== "undefined") {
          dotLottie.setUseFrameInterpolation(newVal);
        }
      }
    );
    function getIntersectionObserver() {
      return new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              dotLottie?.unfreeze();
            } else {
              dotLottie?.freeze();
            }
          });
        },
        {
          threshold: 0
        }
      );
    }
    function getResizeObserver() {
      return new ResizeObserver((entries) => {
        entries.forEach(() => {
          dotLottie?.resize();
        });
      });
    }
    function onVisibilityChange() {
      if (document.hidden) {
        dotLottie?.freeze();
      } else {
        dotLottie?.unfreeze();
      }
    }
    onMounted(() => {
      if (!canvas.value)
        return;
      dotLottie = new DotLottie({
        canvas: canvas.value,
        ...props
      });
      intersectionObserver = getIntersectionObserver();
      resizeObserver = getResizeObserver();
      intersectionObserver.observe(canvas.value);
      resizeObserver.observe(canvas.value);
      document.addEventListener("visibilitychange", onVisibilityChange);
    });
    onBeforeUnmount(() => {
      resizeObserver?.disconnect();
      intersectionObserver?.disconnect();
      document.removeEventListener("visibilitychange", onVisibilityChange);
      dotLottie?.destroy();
    });
    expose({
      getDotLottieInstance: () => dotLottie
    });
    return () => h("div", { ...attrs }, h("canvas", { style: "height: 100%; width: 100%", ref: canvas }));
  }
});

export { DotLottieVue };
